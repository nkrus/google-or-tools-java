// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/constraint_solver/routing_parameters.proto

package com.google.ortools.constraintsolver;

/**
 * <pre>
 * Parameters defining the search used to solve vehicle routing problems.
 * If a parameter is unset (or, equivalently, set to its default value),
 * then the routing library will pick its preferred value for that parameter
 * automatically: this should be the case for most parameters.
 * To see those "default" parameters, call GetDefaultRoutingSearchParameters().
 * </pre>
 *
 * Protobuf type {@code operations_research.RoutingSearchParameters}
 */
public  final class RoutingSearchParameters extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:operations_research.RoutingSearchParameters)
    RoutingSearchParametersOrBuilder {
private static final long serialVersionUID = 0L;
  // Use RoutingSearchParameters.newBuilder() to construct.
  private RoutingSearchParameters(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private RoutingSearchParameters() {
    firstSolutionStrategy_ = 0;
    localSearchMetaheuristic_ = 0;
  }

  @Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private RoutingSearchParameters(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {
            int rawValue = input.readEnum();

            firstSolutionStrategy_ = rawValue;
            break;
          }
          case 16: {

            useUnfilteredFirstSolutionStrategy_ = input.readBool();
            break;
          }
          case 26: {
            com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder subBuilder = null;
            if (localSearchOperators_ != null) {
              subBuilder = localSearchOperators_.toBuilder();
            }
            localSearchOperators_ = input.readMessage(com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(localSearchOperators_);
              localSearchOperators_ = subBuilder.buildPartial();
            }

            break;
          }
          case 32: {
            int rawValue = input.readEnum();

            localSearchMetaheuristic_ = rawValue;
            break;
          }
          case 41: {

            guidedLocalSearchLambdaCoefficient_ = input.readDouble();
            break;
          }
          case 48: {

            useDepthFirstSearch_ = input.readBool();
            break;
          }
          case 57: {

            optimizationStep_ = input.readDouble();
            break;
          }
          case 64: {

            solutionLimit_ = input.readInt64();
            break;
          }
          case 74: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (timeLimit_ != null) {
              subBuilder = timeLimit_.toBuilder();
            }
            timeLimit_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(timeLimit_);
              timeLimit_ = subBuilder.buildPartial();
            }

            break;
          }
          case 82: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (lnsTimeLimit_ != null) {
              subBuilder = lnsTimeLimit_.toBuilder();
            }
            lnsTimeLimit_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(lnsTimeLimit_);
              lnsTimeLimit_ = subBuilder.buildPartial();
            }

            break;
          }
          case 88: {

            useFullPropagation_ = input.readBool();
            break;
          }
          case 104: {

            logSearch_ = input.readBool();
            break;
          }
          case 113: {

            savingsNeighborsRatio_ = input.readDouble();
            break;
          }
          case 120: {

            savingsAddReverseArcs_ = input.readBool();
            break;
          }
          case 129: {

            cheapestInsertionFarthestSeedsRatio_ = input.readDouble();
            break;
          }
          case 136: {

            numberOfSolutionsToCollect_ = input.readInt32();
            break;
          }
          case 145: {

            savingsArcCoefficient_ = input.readDouble();
            break;
          }
          case 152: {

            savingsParallelRoutes_ = input.readBool();
            break;
          }
          case 160: {

            relocateExpensiveChainNumArcsToConsider_ = input.readInt32();
            break;
          }
          case 169: {

            cheapestInsertionNeighborsRatio_ = input.readDouble();
            break;
          }
          case 177: {

            logCostScalingFactor_ = input.readDouble();
            break;
          }
          case 185: {

            savingsMaxMemoryUsageBytes_ = input.readDouble();
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_descriptor;
  }

  @Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.ortools.constraintsolver.RoutingSearchParameters.class, com.google.ortools.constraintsolver.RoutingSearchParameters.Builder.class);
  }

  public interface LocalSearchNeighborhoodOperatorsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * --- Inter-route operators ---
     * Operator which moves a single node to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
     *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
     */
    int getUseRelocateValue();
    /**
     * <pre>
     * --- Inter-route operators ---
     * Operator which moves a single node to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
     *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseRelocate();

    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes to another
     * position where the first node of the pair must be before the second node
     * on the same path. Compared to the light_relocate_pair operator, tries all
     * possible positions of insertion of a pair (not only after another pair).
     * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
     * first and last nodes of the path and can therefore not be moved, and
     * (A, B) is a pair of nodes):
     *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
     *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
     */
    int getUseRelocatePairValue();
    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes to another
     * position where the first node of the pair must be before the second node
     * on the same path. Compared to the light_relocate_pair operator, tries all
     * possible positions of insertion of a pair (not only after another pair).
     * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
     * first and last nodes of the path and can therefore not be moved, and
     * (A, B) is a pair of nodes):
     *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
     *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseRelocatePair();

    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes after another
     * pair.
     * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
     * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
     * be moved, and (A, B) and (C, D) are pair of nodes):
     *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
     *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
     */
    int getUseLightRelocatePairValue();
    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes after another
     * pair.
     * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
     * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
     * be moved, and (A, B) and (C, D) are pair of nodes):
     *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
     *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseLightRelocatePair();

    /**
     * <pre>
     * Relocate neighborhood which moves chains of neighbors.
     * The operator starts by relocating a node n after a node m, then continues
     * moving nodes which were after n as long as the "cost" added is less than
     * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
     * of next variables, it will try reordering the nodes until it finds a
     * valid path.
     * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
     * are first and last nodes of the path and can therefore not be moved, A
     * must be performed before B, and A, D and E are located at the same
     * place):
     * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
     * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
     * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
     * This operator is extremelly useful to move chains of nodes which are
     * located at the same place (for instance nodes part of a same stop).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
     */
    int getUseRelocateNeighborsValue();
    /**
     * <pre>
     * Relocate neighborhood which moves chains of neighbors.
     * The operator starts by relocating a node n after a node m, then continues
     * moving nodes which were after n as long as the "cost" added is less than
     * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
     * of next variables, it will try reordering the nodes until it finds a
     * valid path.
     * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
     * are first and last nodes of the path and can therefore not be moved, A
     * must be performed before B, and A, D and E are located at the same
     * place):
     * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
     * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
     * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
     * This operator is extremelly useful to move chains of nodes which are
     * located at the same place (for instance nodes part of a same stop).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseRelocateNeighbors();

    /**
     * <pre>
     * Relocate neighborhood that moves subpaths all pickup and delivery
     * pairs have both pickup and delivery inside the subpath or both outside
     * the subpath. For instance, for given paths:
     * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
     * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
     */
    int getUseRelocateSubtripValue();
    /**
     * <pre>
     * Relocate neighborhood that moves subpaths all pickup and delivery
     * pairs have both pickup and delivery inside the subpath or both outside
     * the subpath. For instance, for given paths:
     * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
     * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseRelocateSubtrip();

    /**
     * <pre>
     * Operator which exchanges the positions of two nodes.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
     */
    int getUseExchangeValue();
    /**
     * <pre>
     * Operator which exchanges the positions of two nodes.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseExchange();

    /**
     * <pre>
     * Operator which exchanges the positions of two pair of nodes. Pairs
     * correspond to the pickup and delivery pairs defined in the routing model.
     * Possible neighbor for the paths
     * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
     * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
     * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
     *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
     */
    int getUseExchangePairValue();
    /**
     * <pre>
     * Operator which exchanges the positions of two pair of nodes. Pairs
     * correspond to the pickup and delivery pairs defined in the routing model.
     * Possible neighbor for the paths
     * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
     * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
     * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
     *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseExchangePair();

    /**
     * <pre>
     * Operator which exchanges subtrips associated to two pairs of nodes,
     * see use_relocate_subtrip for a definition of subtrips.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
     */
    int getUseExchangeSubtripValue();
    /**
     * <pre>
     * Operator which exchanges subtrips associated to two pairs of nodes,
     * see use_relocate_subtrip for a definition of subtrips.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseExchangeSubtrip();

    /**
     * <pre>
     * Operator which cross exchanges the starting chains of 2 paths, including
     * exchanging the whole paths.
     * First and last nodes are not moved.
     * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
     * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
     * therefore not be moved):
     *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
     *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
     *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
     */
    int getUseCrossValue();
    /**
     * <pre>
     * Operator which cross exchanges the starting chains of 2 paths, including
     * exchanging the whole paths.
     * First and last nodes are not moved.
     * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
     * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
     * therefore not be moved):
     *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
     *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
     *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseCross();

    /**
     * <pre>
     * Not implemented yet. TODO(b/68128619): Implement.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
     */
    int getUseCrossExchangeValue();
    /**
     * <pre>
     * Not implemented yet. TODO(b/68128619): Implement.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseCrossExchange();

    /**
     * <pre>
     * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
     * most expensive arcs on a path, and moves the chain resulting from cutting
     * pairs of arcs among these to another position.
     * Possible neighbors for paths 1 -&gt; 2 (empty) and
     * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
     * most expensive arcs, and the chain resulting from breaking them is
     * B -&gt; C):
     *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
     */
    int getUseRelocateExpensiveChainValue();
    /**
     * <pre>
     * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
     * most expensive arcs on a path, and moves the chain resulting from cutting
     * pairs of arcs among these to another position.
     * Possible neighbors for paths 1 -&gt; 2 (empty) and
     * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
     * most expensive arcs, and the chain resulting from breaking them is
     * B -&gt; C):
     *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseRelocateExpensiveChain();

    /**
     * <pre>
     * --- Intra-route operators ---
     * Operator which reverves a sub-chain of a path. It is called TwoOpt
     * because it breaks two arcs on the path; resulting paths are called
     * two-optimal.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
     *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
     *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
     */
    int getUseTwoOptValue();
    /**
     * <pre>
     * --- Intra-route operators ---
     * Operator which reverves a sub-chain of a path. It is called TwoOpt
     * because it breaks two arcs on the path; resulting paths are called
     * two-optimal.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
     *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
     *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseTwoOpt();

    /**
     * <pre>
     * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
     * position in the same path.
     * When the length of the sub-chain is 1, the operator simply moves a node
     * to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
     * length of 2 (where (1, 5) are first and last nodes of the path and can
     * therefore not be moved):
     *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
     *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
     * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
     * path).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
     */
    int getUseOrOptValue();
    /**
     * <pre>
     * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
     * position in the same path.
     * When the length of the sub-chain is 1, the operator simply moves a node
     * to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
     * length of 2 (where (1, 5) are first and last nodes of the path and can
     * therefore not be moved):
     *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
     *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
     * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
     * path).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseOrOpt();

    /**
     * <pre>
     * Lin-Kernighan operator.
     * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
     * move followed by a series of 2-OPT moves. Returns a neighbor for which
     * the global gain is positive.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
     */
    int getUseLinKernighanValue();
    /**
     * <pre>
     * Lin-Kernighan operator.
     * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
     * move followed by a series of 2-OPT moves. Returns a neighbor for which
     * the global gain is positive.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseLinKernighan();

    /**
     * <pre>
     * Sliding TSP operator.
     * Uses an exact dynamic programming algorithm to solve the TSP
     * corresponding to path sub-chains.
     * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
     * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
     * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
     */
    int getUseTspOptValue();
    /**
     * <pre>
     * Sliding TSP operator.
     * Uses an exact dynamic programming algorithm to solve the TSP
     * corresponding to path sub-chains.
     * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
     * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
     * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseTspOpt();

    /**
     * <pre>
     * --- Operators on inactive nodes ---
     * Operator which inserts an inactive node into a path.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
     */
    int getUseMakeActiveValue();
    /**
     * <pre>
     * --- Operators on inactive nodes ---
     * Operator which inserts an inactive node into a path.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseMakeActive();

    /**
     * <pre>
     * Operator which relocates a node while making an inactive one active.
     * As of 3/2017, the operator is limited to two kinds of moves:
     * - Relocating a node and replacing it by an inactive node.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
     * - Relocating a node and inserting an inactive node next to it.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
     */
    int getUseRelocateAndMakeActiveValue();
    /**
     * <pre>
     * Operator which relocates a node while making an inactive one active.
     * As of 3/2017, the operator is limited to two kinds of moves:
     * - Relocating a node and replacing it by an inactive node.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
     * - Relocating a node and inserting an inactive node next to it.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseRelocateAndMakeActive();

    /**
     * <pre>
     * Operator which makes path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
     */
    int getUseMakeInactiveValue();
    /**
     * <pre>
     * Operator which makes path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseMakeInactive();

    /**
     * <pre>
     * Operator which makes a "chain" of path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     *   1 -&gt; 4 with 2 and 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
     */
    int getUseMakeChainInactiveValue();
    /**
     * <pre>
     * Operator which makes a "chain" of path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     *   1 -&gt; 4 with 2 and 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseMakeChainInactive();

    /**
     * <pre>
     * Operator which replaces an active node by an inactive one.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
     */
    int getUseSwapActiveValue();
    /**
     * <pre>
     * Operator which replaces an active node by an inactive one.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseSwapActive();

    /**
     * <pre>
     * Operator which makes an inactive node active and an active one inactive.
     * It is similar to SwapActiveOperator excepts that it tries to insert the
     * inactive node in all possible positions instead of just the position of
     * the node made inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
     *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
     */
    int getUseExtendedSwapActiveValue();
    /**
     * <pre>
     * Operator which makes an inactive node active and an active one inactive.
     * It is similar to SwapActiveOperator excepts that it tries to insert the
     * inactive node in all possible positions instead of just the position of
     * the node made inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
     *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseExtendedSwapActive();

    /**
     * <pre>
     * Operator which makes an inactive node active and an active pair of nodes
     * inactive OR makes an inactive pair of nodes active and an active node
     * inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
     * of nodes) are:
     *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
     * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
     * of nodes) are:
     *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
     */
    int getUseNodePairSwapActiveValue();
    /**
     * <pre>
     * Operator which makes an inactive node active and an active pair of nodes
     * inactive OR makes an inactive pair of nodes active and an active node
     * inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
     * of nodes) are:
     *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
     * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
     * of nodes) are:
     *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseNodePairSwapActive();

    /**
     * <pre>
     * --- Large neighborhood search operators ---
     * Operator which relaxes two sub-chains of three consecutive arcs each.
     * Each sub-chain is defined by a start node and the next three arcs. Those
     * six arcs are relaxed to build a new neighbor.
     * PATH_LNS explores all possible pairs of starting nodes and so defines
     * n^2 neighbors, n being the number of nodes.
     * Note that the two sub-chains can be part of the same path; they even may
     * overlap.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
     */
    int getUsePathLnsValue();
    /**
     * <pre>
     * --- Large neighborhood search operators ---
     * Operator which relaxes two sub-chains of three consecutive arcs each.
     * Each sub-chain is defined by a start node and the next three arcs. Those
     * six arcs are relaxed to build a new neighbor.
     * PATH_LNS explores all possible pairs of starting nodes and so defines
     * n^2 neighbors, n being the number of nodes.
     * Note that the two sub-chains can be part of the same path; they even may
     * overlap.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
     */
    com.google.ortools.util.OptionalBoolean getUsePathLns();

    /**
     * <pre>
     * Operator which relaxes one entire path and all unactive nodes.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
     */
    int getUseFullPathLnsValue();
    /**
     * <pre>
     * Operator which relaxes one entire path and all unactive nodes.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseFullPathLns();

    /**
     * <pre>
     * TSP-base LNS.
     * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
     * the corresponding TSP.
     * This defines an "unlimited" neighborhood which must be stopped by search
     * limits. To force diversification, the operator iteratively forces each
     * node to serve as base of a meta-node.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
     */
    int getUseTspLnsValue();
    /**
     * <pre>
     * TSP-base LNS.
     * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
     * the corresponding TSP.
     * This defines an "unlimited" neighborhood which must be stopped by search
     * limits. To force diversification, the operator iteratively forces each
     * node to serve as base of a meta-node.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseTspLns();

    /**
     * <pre>
     * Operator which relaxes all inactive nodes and one sub-chain of six
     * consecutive arcs. That way the path can be improved by inserting inactive
     * nodes or swaping arcs.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
     */
    int getUseInactiveLnsValue();
    /**
     * <pre>
     * Operator which relaxes all inactive nodes and one sub-chain of six
     * consecutive arcs. That way the path can be improved by inserting inactive
     * nodes or swaping arcs.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
     */
    com.google.ortools.util.OptionalBoolean getUseInactiveLns();
  }
  /**
   * <pre>
   * Local search neighborhood operators used to build a solutions neighborhood.
   * Next ID: 27
   * </pre>
   *
   * Protobuf type {@code operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators}
   */
  public  static final class LocalSearchNeighborhoodOperators extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators)
      LocalSearchNeighborhoodOperatorsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LocalSearchNeighborhoodOperators.newBuilder() to construct.
    private LocalSearchNeighborhoodOperators(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LocalSearchNeighborhoodOperators() {
      useRelocate_ = 0;
      useRelocatePair_ = 0;
      useLightRelocatePair_ = 0;
      useRelocateNeighbors_ = 0;
      useRelocateSubtrip_ = 0;
      useExchange_ = 0;
      useExchangePair_ = 0;
      useExchangeSubtrip_ = 0;
      useCross_ = 0;
      useCrossExchange_ = 0;
      useRelocateExpensiveChain_ = 0;
      useTwoOpt_ = 0;
      useOrOpt_ = 0;
      useLinKernighan_ = 0;
      useTspOpt_ = 0;
      useMakeActive_ = 0;
      useRelocateAndMakeActive_ = 0;
      useMakeInactive_ = 0;
      useMakeChainInactive_ = 0;
      useSwapActive_ = 0;
      useExtendedSwapActive_ = 0;
      useNodePairSwapActive_ = 0;
      usePathLns_ = 0;
      useFullPathLns_ = 0;
      useTspLns_ = 0;
      useInactiveLns_ = 0;
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private LocalSearchNeighborhoodOperators(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();

              useRelocate_ = rawValue;
              break;
            }
            case 16: {
              int rawValue = input.readEnum();

              useRelocatePair_ = rawValue;
              break;
            }
            case 24: {
              int rawValue = input.readEnum();

              useRelocateNeighbors_ = rawValue;
              break;
            }
            case 32: {
              int rawValue = input.readEnum();

              useExchange_ = rawValue;
              break;
            }
            case 40: {
              int rawValue = input.readEnum();

              useCross_ = rawValue;
              break;
            }
            case 48: {
              int rawValue = input.readEnum();

              useCrossExchange_ = rawValue;
              break;
            }
            case 56: {
              int rawValue = input.readEnum();

              useTwoOpt_ = rawValue;
              break;
            }
            case 64: {
              int rawValue = input.readEnum();

              useOrOpt_ = rawValue;
              break;
            }
            case 72: {
              int rawValue = input.readEnum();

              useLinKernighan_ = rawValue;
              break;
            }
            case 80: {
              int rawValue = input.readEnum();

              useTspOpt_ = rawValue;
              break;
            }
            case 88: {
              int rawValue = input.readEnum();

              useMakeActive_ = rawValue;
              break;
            }
            case 96: {
              int rawValue = input.readEnum();

              useMakeInactive_ = rawValue;
              break;
            }
            case 104: {
              int rawValue = input.readEnum();

              useMakeChainInactive_ = rawValue;
              break;
            }
            case 112: {
              int rawValue = input.readEnum();

              useSwapActive_ = rawValue;
              break;
            }
            case 120: {
              int rawValue = input.readEnum();

              useExtendedSwapActive_ = rawValue;
              break;
            }
            case 128: {
              int rawValue = input.readEnum();

              usePathLns_ = rawValue;
              break;
            }
            case 136: {
              int rawValue = input.readEnum();

              useFullPathLns_ = rawValue;
              break;
            }
            case 144: {
              int rawValue = input.readEnum();

              useTspLns_ = rawValue;
              break;
            }
            case 152: {
              int rawValue = input.readEnum();

              useInactiveLns_ = rawValue;
              break;
            }
            case 160: {
              int rawValue = input.readEnum();

              useNodePairSwapActive_ = rawValue;
              break;
            }
            case 168: {
              int rawValue = input.readEnum();

              useRelocateAndMakeActive_ = rawValue;
              break;
            }
            case 176: {
              int rawValue = input.readEnum();

              useExchangePair_ = rawValue;
              break;
            }
            case 184: {
              int rawValue = input.readEnum();

              useRelocateExpensiveChain_ = rawValue;
              break;
            }
            case 192: {
              int rawValue = input.readEnum();

              useLightRelocatePair_ = rawValue;
              break;
            }
            case 200: {
              int rawValue = input.readEnum();

              useRelocateSubtrip_ = rawValue;
              break;
            }
            case 208: {
              int rawValue = input.readEnum();

              useExchangeSubtrip_ = rawValue;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_LocalSearchNeighborhoodOperators_descriptor;
    }

    @Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_LocalSearchNeighborhoodOperators_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.class, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder.class);
    }

    public static final int USE_RELOCATE_FIELD_NUMBER = 1;
    private int useRelocate_;
    /**
     * <pre>
     * --- Inter-route operators ---
     * Operator which moves a single node to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
     *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
     */
    public int getUseRelocateValue() {
      return useRelocate_;
    }
    /**
     * <pre>
     * --- Inter-route operators ---
     * Operator which moves a single node to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
     *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseRelocate() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocate_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_RELOCATE_PAIR_FIELD_NUMBER = 2;
    private int useRelocatePair_;
    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes to another
     * position where the first node of the pair must be before the second node
     * on the same path. Compared to the light_relocate_pair operator, tries all
     * possible positions of insertion of a pair (not only after another pair).
     * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
     * first and last nodes of the path and can therefore not be moved, and
     * (A, B) is a pair of nodes):
     *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
     *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
     */
    public int getUseRelocatePairValue() {
      return useRelocatePair_;
    }
    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes to another
     * position where the first node of the pair must be before the second node
     * on the same path. Compared to the light_relocate_pair operator, tries all
     * possible positions of insertion of a pair (not only after another pair).
     * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
     * first and last nodes of the path and can therefore not be moved, and
     * (A, B) is a pair of nodes):
     *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
     *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseRelocatePair() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocatePair_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_LIGHT_RELOCATE_PAIR_FIELD_NUMBER = 24;
    private int useLightRelocatePair_;
    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes after another
     * pair.
     * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
     * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
     * be moved, and (A, B) and (C, D) are pair of nodes):
     *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
     *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
     */
    public int getUseLightRelocatePairValue() {
      return useLightRelocatePair_;
    }
    /**
     * <pre>
     * Operator which moves a pair of pickup and delivery nodes after another
     * pair.
     * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
     * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
     * be moved, and (A, B) and (C, D) are pair of nodes):
     *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
     *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseLightRelocatePair() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useLightRelocatePair_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_RELOCATE_NEIGHBORS_FIELD_NUMBER = 3;
    private int useRelocateNeighbors_;
    /**
     * <pre>
     * Relocate neighborhood which moves chains of neighbors.
     * The operator starts by relocating a node n after a node m, then continues
     * moving nodes which were after n as long as the "cost" added is less than
     * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
     * of next variables, it will try reordering the nodes until it finds a
     * valid path.
     * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
     * are first and last nodes of the path and can therefore not be moved, A
     * must be performed before B, and A, D and E are located at the same
     * place):
     * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
     * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
     * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
     * This operator is extremelly useful to move chains of nodes which are
     * located at the same place (for instance nodes part of a same stop).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
     */
    public int getUseRelocateNeighborsValue() {
      return useRelocateNeighbors_;
    }
    /**
     * <pre>
     * Relocate neighborhood which moves chains of neighbors.
     * The operator starts by relocating a node n after a node m, then continues
     * moving nodes which were after n as long as the "cost" added is less than
     * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
     * of next variables, it will try reordering the nodes until it finds a
     * valid path.
     * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
     * are first and last nodes of the path and can therefore not be moved, A
     * must be performed before B, and A, D and E are located at the same
     * place):
     * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
     * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
     * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
     * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
     * This operator is extremelly useful to move chains of nodes which are
     * located at the same place (for instance nodes part of a same stop).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseRelocateNeighbors() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateNeighbors_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_RELOCATE_SUBTRIP_FIELD_NUMBER = 25;
    private int useRelocateSubtrip_;
    /**
     * <pre>
     * Relocate neighborhood that moves subpaths all pickup and delivery
     * pairs have both pickup and delivery inside the subpath or both outside
     * the subpath. For instance, for given paths:
     * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
     * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
     */
    public int getUseRelocateSubtripValue() {
      return useRelocateSubtrip_;
    }
    /**
     * <pre>
     * Relocate neighborhood that moves subpaths all pickup and delivery
     * pairs have both pickup and delivery inside the subpath or both outside
     * the subpath. For instance, for given paths:
     * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
     * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
     * 7 -&gt; 9
     * 0 -&gt; 5 -&gt; 6 -&gt; 8
     * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseRelocateSubtrip() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateSubtrip_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_EXCHANGE_FIELD_NUMBER = 4;
    private int useExchange_;
    /**
     * <pre>
     * Operator which exchanges the positions of two nodes.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
     */
    public int getUseExchangeValue() {
      return useExchange_;
    }
    /**
     * <pre>
     * Operator which exchanges the positions of two nodes.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
     *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
     *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseExchange() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExchange_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_EXCHANGE_PAIR_FIELD_NUMBER = 22;
    private int useExchangePair_;
    /**
     * <pre>
     * Operator which exchanges the positions of two pair of nodes. Pairs
     * correspond to the pickup and delivery pairs defined in the routing model.
     * Possible neighbor for the paths
     * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
     * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
     * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
     *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
     */
    public int getUseExchangePairValue() {
      return useExchangePair_;
    }
    /**
     * <pre>
     * Operator which exchanges the positions of two pair of nodes. Pairs
     * correspond to the pickup and delivery pairs defined in the routing model.
     * Possible neighbor for the paths
     * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
     * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
     * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
     *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseExchangePair() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExchangePair_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_EXCHANGE_SUBTRIP_FIELD_NUMBER = 26;
    private int useExchangeSubtrip_;
    /**
     * <pre>
     * Operator which exchanges subtrips associated to two pairs of nodes,
     * see use_relocate_subtrip for a definition of subtrips.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
     */
    public int getUseExchangeSubtripValue() {
      return useExchangeSubtrip_;
    }
    /**
     * <pre>
     * Operator which exchanges subtrips associated to two pairs of nodes,
     * see use_relocate_subtrip for a definition of subtrips.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseExchangeSubtrip() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExchangeSubtrip_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_CROSS_FIELD_NUMBER = 5;
    private int useCross_;
    /**
     * <pre>
     * Operator which cross exchanges the starting chains of 2 paths, including
     * exchanging the whole paths.
     * First and last nodes are not moved.
     * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
     * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
     * therefore not be moved):
     *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
     *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
     *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
     */
    public int getUseCrossValue() {
      return useCross_;
    }
    /**
     * <pre>
     * Operator which cross exchanges the starting chains of 2 paths, including
     * exchanging the whole paths.
     * First and last nodes are not moved.
     * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
     * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
     * therefore not be moved):
     *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
     *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
     *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseCross() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useCross_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_CROSS_EXCHANGE_FIELD_NUMBER = 6;
    private int useCrossExchange_;
    /**
     * <pre>
     * Not implemented yet. TODO(b/68128619): Implement.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
     */
    public int getUseCrossExchangeValue() {
      return useCrossExchange_;
    }
    /**
     * <pre>
     * Not implemented yet. TODO(b/68128619): Implement.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseCrossExchange() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useCrossExchange_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_RELOCATE_EXPENSIVE_CHAIN_FIELD_NUMBER = 23;
    private int useRelocateExpensiveChain_;
    /**
     * <pre>
     * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
     * most expensive arcs on a path, and moves the chain resulting from cutting
     * pairs of arcs among these to another position.
     * Possible neighbors for paths 1 -&gt; 2 (empty) and
     * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
     * most expensive arcs, and the chain resulting from breaking them is
     * B -&gt; C):
     *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
     */
    public int getUseRelocateExpensiveChainValue() {
      return useRelocateExpensiveChain_;
    }
    /**
     * <pre>
     * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
     * most expensive arcs on a path, and moves the chain resulting from cutting
     * pairs of arcs among these to another position.
     * Possible neighbors for paths 1 -&gt; 2 (empty) and
     * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
     * most expensive arcs, and the chain resulting from breaking them is
     * B -&gt; C):
     *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
     *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseRelocateExpensiveChain() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateExpensiveChain_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_TWO_OPT_FIELD_NUMBER = 7;
    private int useTwoOpt_;
    /**
     * <pre>
     * --- Intra-route operators ---
     * Operator which reverves a sub-chain of a path. It is called TwoOpt
     * because it breaks two arcs on the path; resulting paths are called
     * two-optimal.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
     *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
     *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
     */
    public int getUseTwoOptValue() {
      return useTwoOpt_;
    }
    /**
     * <pre>
     * --- Intra-route operators ---
     * Operator which reverves a sub-chain of a path. It is called TwoOpt
     * because it breaks two arcs on the path; resulting paths are called
     * two-optimal.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
     * (where (1, 5) are first and last nodes of the path and can therefore not
     * be moved):
     *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
     *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
     *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseTwoOpt() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useTwoOpt_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_OR_OPT_FIELD_NUMBER = 8;
    private int useOrOpt_;
    /**
     * <pre>
     * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
     * position in the same path.
     * When the length of the sub-chain is 1, the operator simply moves a node
     * to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
     * length of 2 (where (1, 5) are first and last nodes of the path and can
     * therefore not be moved):
     *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
     *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
     * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
     * path).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
     */
    public int getUseOrOptValue() {
      return useOrOpt_;
    }
    /**
     * <pre>
     * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
     * position in the same path.
     * When the length of the sub-chain is 1, the operator simply moves a node
     * to another position.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
     * length of 2 (where (1, 5) are first and last nodes of the path and can
     * therefore not be moved):
     *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
     *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
     * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
     * path).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseOrOpt() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useOrOpt_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_LIN_KERNIGHAN_FIELD_NUMBER = 9;
    private int useLinKernighan_;
    /**
     * <pre>
     * Lin-Kernighan operator.
     * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
     * move followed by a series of 2-OPT moves. Returns a neighbor for which
     * the global gain is positive.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
     */
    public int getUseLinKernighanValue() {
      return useLinKernighan_;
    }
    /**
     * <pre>
     * Lin-Kernighan operator.
     * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
     * move followed by a series of 2-OPT moves. Returns a neighbor for which
     * the global gain is positive.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseLinKernighan() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useLinKernighan_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_TSP_OPT_FIELD_NUMBER = 10;
    private int useTspOpt_;
    /**
     * <pre>
     * Sliding TSP operator.
     * Uses an exact dynamic programming algorithm to solve the TSP
     * corresponding to path sub-chains.
     * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
     * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
     * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
     */
    public int getUseTspOptValue() {
      return useTspOpt_;
    }
    /**
     * <pre>
     * Sliding TSP operator.
     * Uses an exact dynamic programming algorithm to solve the TSP
     * corresponding to path sub-chains.
     * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
     * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
     * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseTspOpt() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useTspOpt_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_MAKE_ACTIVE_FIELD_NUMBER = 11;
    private int useMakeActive_;
    /**
     * <pre>
     * --- Operators on inactive nodes ---
     * Operator which inserts an inactive node into a path.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
     */
    public int getUseMakeActiveValue() {
      return useMakeActive_;
    }
    /**
     * <pre>
     * --- Operators on inactive nodes ---
     * Operator which inserts an inactive node into a path.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
     *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseMakeActive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useMakeActive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_RELOCATE_AND_MAKE_ACTIVE_FIELD_NUMBER = 21;
    private int useRelocateAndMakeActive_;
    /**
     * <pre>
     * Operator which relocates a node while making an inactive one active.
     * As of 3/2017, the operator is limited to two kinds of moves:
     * - Relocating a node and replacing it by an inactive node.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
     * - Relocating a node and inserting an inactive node next to it.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
     */
    public int getUseRelocateAndMakeActiveValue() {
      return useRelocateAndMakeActive_;
    }
    /**
     * <pre>
     * Operator which relocates a node while making an inactive one active.
     * As of 3/2017, the operator is limited to two kinds of moves:
     * - Relocating a node and replacing it by an inactive node.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
     * - Relocating a node and inserting an inactive node next to it.
     *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
     *   (where 1,2 and 5,6 are first and last nodes of paths) is:
     *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseRelocateAndMakeActive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateAndMakeActive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_MAKE_INACTIVE_FIELD_NUMBER = 12;
    private int useMakeInactive_;
    /**
     * <pre>
     * Operator which makes path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
     */
    public int getUseMakeInactiveValue() {
      return useMakeInactive_;
    }
    /**
     * <pre>
     * Operator which makes path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseMakeInactive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useMakeInactive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_MAKE_CHAIN_INACTIVE_FIELD_NUMBER = 13;
    private int useMakeChainInactive_;
    /**
     * <pre>
     * Operator which makes a "chain" of path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     *   1 -&gt; 4 with 2 and 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
     */
    public int getUseMakeChainInactiveValue() {
      return useMakeChainInactive_;
    }
    /**
     * <pre>
     * Operator which makes a "chain" of path nodes inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
     * and last nodes of the path) are:
     *   1 -&gt; 3 -&gt; 4 with 2 inactive
     *   1 -&gt; 2 -&gt; 4 with 3 inactive
     *   1 -&gt; 4 with 2 and 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseMakeChainInactive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useMakeChainInactive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_SWAP_ACTIVE_FIELD_NUMBER = 14;
    private int useSwapActive_;
    /**
     * <pre>
     * Operator which replaces an active node by an inactive one.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
     */
    public int getUseSwapActiveValue() {
      return useSwapActive_;
    }
    /**
     * <pre>
     * Operator which replaces an active node by an inactive one.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseSwapActive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useSwapActive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_EXTENDED_SWAP_ACTIVE_FIELD_NUMBER = 15;
    private int useExtendedSwapActive_;
    /**
     * <pre>
     * Operator which makes an inactive node active and an active one inactive.
     * It is similar to SwapActiveOperator excepts that it tries to insert the
     * inactive node in all possible positions instead of just the position of
     * the node made inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
     *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
     */
    public int getUseExtendedSwapActiveValue() {
      return useExtendedSwapActive_;
    }
    /**
     * <pre>
     * Operator which makes an inactive node active and an active one inactive.
     * It is similar to SwapActiveOperator excepts that it tries to insert the
     * inactive node in all possible positions instead of just the position of
     * the node made inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path) are:
     *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
     *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
     *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
     *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseExtendedSwapActive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExtendedSwapActive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_NODE_PAIR_SWAP_ACTIVE_FIELD_NUMBER = 20;
    private int useNodePairSwapActive_;
    /**
     * <pre>
     * Operator which makes an inactive node active and an active pair of nodes
     * inactive OR makes an inactive pair of nodes active and an active node
     * inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
     * of nodes) are:
     *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
     * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
     * of nodes) are:
     *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
     */
    public int getUseNodePairSwapActiveValue() {
      return useNodePairSwapActive_;
    }
    /**
     * <pre>
     * Operator which makes an inactive node active and an active pair of nodes
     * inactive OR makes an inactive pair of nodes active and an active node
     * inactive.
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
     * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
     * of nodes) are:
     *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
     * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
     * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
     * of nodes) are:
     *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseNodePairSwapActive() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useNodePairSwapActive_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_PATH_LNS_FIELD_NUMBER = 16;
    private int usePathLns_;
    /**
     * <pre>
     * --- Large neighborhood search operators ---
     * Operator which relaxes two sub-chains of three consecutive arcs each.
     * Each sub-chain is defined by a start node and the next three arcs. Those
     * six arcs are relaxed to build a new neighbor.
     * PATH_LNS explores all possible pairs of starting nodes and so defines
     * n^2 neighbors, n being the number of nodes.
     * Note that the two sub-chains can be part of the same path; they even may
     * overlap.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
     */
    public int getUsePathLnsValue() {
      return usePathLns_;
    }
    /**
     * <pre>
     * --- Large neighborhood search operators ---
     * Operator which relaxes two sub-chains of three consecutive arcs each.
     * Each sub-chain is defined by a start node and the next three arcs. Those
     * six arcs are relaxed to build a new neighbor.
     * PATH_LNS explores all possible pairs of starting nodes and so defines
     * n^2 neighbors, n being the number of nodes.
     * Note that the two sub-chains can be part of the same path; they even may
     * overlap.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUsePathLns() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(usePathLns_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_FULL_PATH_LNS_FIELD_NUMBER = 17;
    private int useFullPathLns_;
    /**
     * <pre>
     * Operator which relaxes one entire path and all unactive nodes.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
     */
    public int getUseFullPathLnsValue() {
      return useFullPathLns_;
    }
    /**
     * <pre>
     * Operator which relaxes one entire path and all unactive nodes.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseFullPathLns() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useFullPathLns_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_TSP_LNS_FIELD_NUMBER = 18;
    private int useTspLns_;
    /**
     * <pre>
     * TSP-base LNS.
     * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
     * the corresponding TSP.
     * This defines an "unlimited" neighborhood which must be stopped by search
     * limits. To force diversification, the operator iteratively forces each
     * node to serve as base of a meta-node.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
     */
    public int getUseTspLnsValue() {
      return useTspLns_;
    }
    /**
     * <pre>
     * TSP-base LNS.
     * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
     * the corresponding TSP.
     * This defines an "unlimited" neighborhood which must be stopped by search
     * limits. To force diversification, the operator iteratively forces each
     * node to serve as base of a meta-node.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseTspLns() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useTspLns_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    public static final int USE_INACTIVE_LNS_FIELD_NUMBER = 19;
    private int useInactiveLns_;
    /**
     * <pre>
     * Operator which relaxes all inactive nodes and one sub-chain of six
     * consecutive arcs. That way the path can be improved by inserting inactive
     * nodes or swaping arcs.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
     */
    public int getUseInactiveLnsValue() {
      return useInactiveLns_;
    }
    /**
     * <pre>
     * Operator which relaxes all inactive nodes and one sub-chain of six
     * consecutive arcs. That way the path can be improved by inserting inactive
     * nodes or swaping arcs.
     * </pre>
     *
     * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
     */
    public com.google.ortools.util.OptionalBoolean getUseInactiveLns() {
      @SuppressWarnings("deprecation")
      com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useInactiveLns_);
      return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (useRelocate_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(1, useRelocate_);
      }
      if (useRelocatePair_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(2, useRelocatePair_);
      }
      if (useRelocateNeighbors_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(3, useRelocateNeighbors_);
      }
      if (useExchange_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(4, useExchange_);
      }
      if (useCross_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(5, useCross_);
      }
      if (useCrossExchange_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(6, useCrossExchange_);
      }
      if (useTwoOpt_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(7, useTwoOpt_);
      }
      if (useOrOpt_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(8, useOrOpt_);
      }
      if (useLinKernighan_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(9, useLinKernighan_);
      }
      if (useTspOpt_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(10, useTspOpt_);
      }
      if (useMakeActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(11, useMakeActive_);
      }
      if (useMakeInactive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(12, useMakeInactive_);
      }
      if (useMakeChainInactive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(13, useMakeChainInactive_);
      }
      if (useSwapActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(14, useSwapActive_);
      }
      if (useExtendedSwapActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(15, useExtendedSwapActive_);
      }
      if (usePathLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(16, usePathLns_);
      }
      if (useFullPathLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(17, useFullPathLns_);
      }
      if (useTspLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(18, useTspLns_);
      }
      if (useInactiveLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(19, useInactiveLns_);
      }
      if (useNodePairSwapActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(20, useNodePairSwapActive_);
      }
      if (useRelocateAndMakeActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(21, useRelocateAndMakeActive_);
      }
      if (useExchangePair_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(22, useExchangePair_);
      }
      if (useRelocateExpensiveChain_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(23, useRelocateExpensiveChain_);
      }
      if (useLightRelocatePair_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(24, useLightRelocatePair_);
      }
      if (useRelocateSubtrip_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(25, useRelocateSubtrip_);
      }
      if (useExchangeSubtrip_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        output.writeEnum(26, useExchangeSubtrip_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (useRelocate_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, useRelocate_);
      }
      if (useRelocatePair_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, useRelocatePair_);
      }
      if (useRelocateNeighbors_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, useRelocateNeighbors_);
      }
      if (useExchange_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, useExchange_);
      }
      if (useCross_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(5, useCross_);
      }
      if (useCrossExchange_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, useCrossExchange_);
      }
      if (useTwoOpt_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(7, useTwoOpt_);
      }
      if (useOrOpt_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(8, useOrOpt_);
      }
      if (useLinKernighan_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(9, useLinKernighan_);
      }
      if (useTspOpt_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, useTspOpt_);
      }
      if (useMakeActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(11, useMakeActive_);
      }
      if (useMakeInactive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(12, useMakeInactive_);
      }
      if (useMakeChainInactive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(13, useMakeChainInactive_);
      }
      if (useSwapActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(14, useSwapActive_);
      }
      if (useExtendedSwapActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(15, useExtendedSwapActive_);
      }
      if (usePathLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(16, usePathLns_);
      }
      if (useFullPathLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(17, useFullPathLns_);
      }
      if (useTspLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(18, useTspLns_);
      }
      if (useInactiveLns_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(19, useInactiveLns_);
      }
      if (useNodePairSwapActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(20, useNodePairSwapActive_);
      }
      if (useRelocateAndMakeActive_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(21, useRelocateAndMakeActive_);
      }
      if (useExchangePair_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(22, useExchangePair_);
      }
      if (useRelocateExpensiveChain_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(23, useRelocateExpensiveChain_);
      }
      if (useLightRelocatePair_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(24, useLightRelocatePair_);
      }
      if (useRelocateSubtrip_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(25, useRelocateSubtrip_);
      }
      if (useExchangeSubtrip_ != com.google.ortools.util.OptionalBoolean.BOOL_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(26, useExchangeSubtrip_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators)) {
        return super.equals(obj);
      }
      com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators other = (com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators) obj;

      if (useRelocate_ != other.useRelocate_) return false;
      if (useRelocatePair_ != other.useRelocatePair_) return false;
      if (useLightRelocatePair_ != other.useLightRelocatePair_) return false;
      if (useRelocateNeighbors_ != other.useRelocateNeighbors_) return false;
      if (useRelocateSubtrip_ != other.useRelocateSubtrip_) return false;
      if (useExchange_ != other.useExchange_) return false;
      if (useExchangePair_ != other.useExchangePair_) return false;
      if (useExchangeSubtrip_ != other.useExchangeSubtrip_) return false;
      if (useCross_ != other.useCross_) return false;
      if (useCrossExchange_ != other.useCrossExchange_) return false;
      if (useRelocateExpensiveChain_ != other.useRelocateExpensiveChain_) return false;
      if (useTwoOpt_ != other.useTwoOpt_) return false;
      if (useOrOpt_ != other.useOrOpt_) return false;
      if (useLinKernighan_ != other.useLinKernighan_) return false;
      if (useTspOpt_ != other.useTspOpt_) return false;
      if (useMakeActive_ != other.useMakeActive_) return false;
      if (useRelocateAndMakeActive_ != other.useRelocateAndMakeActive_) return false;
      if (useMakeInactive_ != other.useMakeInactive_) return false;
      if (useMakeChainInactive_ != other.useMakeChainInactive_) return false;
      if (useSwapActive_ != other.useSwapActive_) return false;
      if (useExtendedSwapActive_ != other.useExtendedSwapActive_) return false;
      if (useNodePairSwapActive_ != other.useNodePairSwapActive_) return false;
      if (usePathLns_ != other.usePathLns_) return false;
      if (useFullPathLns_ != other.useFullPathLns_) return false;
      if (useTspLns_ != other.useTspLns_) return false;
      if (useInactiveLns_ != other.useInactiveLns_) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + USE_RELOCATE_FIELD_NUMBER;
      hash = (53 * hash) + useRelocate_;
      hash = (37 * hash) + USE_RELOCATE_PAIR_FIELD_NUMBER;
      hash = (53 * hash) + useRelocatePair_;
      hash = (37 * hash) + USE_LIGHT_RELOCATE_PAIR_FIELD_NUMBER;
      hash = (53 * hash) + useLightRelocatePair_;
      hash = (37 * hash) + USE_RELOCATE_NEIGHBORS_FIELD_NUMBER;
      hash = (53 * hash) + useRelocateNeighbors_;
      hash = (37 * hash) + USE_RELOCATE_SUBTRIP_FIELD_NUMBER;
      hash = (53 * hash) + useRelocateSubtrip_;
      hash = (37 * hash) + USE_EXCHANGE_FIELD_NUMBER;
      hash = (53 * hash) + useExchange_;
      hash = (37 * hash) + USE_EXCHANGE_PAIR_FIELD_NUMBER;
      hash = (53 * hash) + useExchangePair_;
      hash = (37 * hash) + USE_EXCHANGE_SUBTRIP_FIELD_NUMBER;
      hash = (53 * hash) + useExchangeSubtrip_;
      hash = (37 * hash) + USE_CROSS_FIELD_NUMBER;
      hash = (53 * hash) + useCross_;
      hash = (37 * hash) + USE_CROSS_EXCHANGE_FIELD_NUMBER;
      hash = (53 * hash) + useCrossExchange_;
      hash = (37 * hash) + USE_RELOCATE_EXPENSIVE_CHAIN_FIELD_NUMBER;
      hash = (53 * hash) + useRelocateExpensiveChain_;
      hash = (37 * hash) + USE_TWO_OPT_FIELD_NUMBER;
      hash = (53 * hash) + useTwoOpt_;
      hash = (37 * hash) + USE_OR_OPT_FIELD_NUMBER;
      hash = (53 * hash) + useOrOpt_;
      hash = (37 * hash) + USE_LIN_KERNIGHAN_FIELD_NUMBER;
      hash = (53 * hash) + useLinKernighan_;
      hash = (37 * hash) + USE_TSP_OPT_FIELD_NUMBER;
      hash = (53 * hash) + useTspOpt_;
      hash = (37 * hash) + USE_MAKE_ACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useMakeActive_;
      hash = (37 * hash) + USE_RELOCATE_AND_MAKE_ACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useRelocateAndMakeActive_;
      hash = (37 * hash) + USE_MAKE_INACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useMakeInactive_;
      hash = (37 * hash) + USE_MAKE_CHAIN_INACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useMakeChainInactive_;
      hash = (37 * hash) + USE_SWAP_ACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useSwapActive_;
      hash = (37 * hash) + USE_EXTENDED_SWAP_ACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useExtendedSwapActive_;
      hash = (37 * hash) + USE_NODE_PAIR_SWAP_ACTIVE_FIELD_NUMBER;
      hash = (53 * hash) + useNodePairSwapActive_;
      hash = (37 * hash) + USE_PATH_LNS_FIELD_NUMBER;
      hash = (53 * hash) + usePathLns_;
      hash = (37 * hash) + USE_FULL_PATH_LNS_FIELD_NUMBER;
      hash = (53 * hash) + useFullPathLns_;
      hash = (37 * hash) + USE_TSP_LNS_FIELD_NUMBER;
      hash = (53 * hash) + useTspLns_;
      hash = (37 * hash) + USE_INACTIVE_LNS_FIELD_NUMBER;
      hash = (53 * hash) + useInactiveLns_;
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Local search neighborhood operators used to build a solutions neighborhood.
     * Next ID: 27
     * </pre>
     *
     * Protobuf type {@code operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators)
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_LocalSearchNeighborhoodOperators_descriptor;
      }

      @Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_LocalSearchNeighborhoodOperators_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.class, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder.class);
      }

      // Construct using com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        useRelocate_ = 0;

        useRelocatePair_ = 0;

        useLightRelocatePair_ = 0;

        useRelocateNeighbors_ = 0;

        useRelocateSubtrip_ = 0;

        useExchange_ = 0;

        useExchangePair_ = 0;

        useExchangeSubtrip_ = 0;

        useCross_ = 0;

        useCrossExchange_ = 0;

        useRelocateExpensiveChain_ = 0;

        useTwoOpt_ = 0;

        useOrOpt_ = 0;

        useLinKernighan_ = 0;

        useTspOpt_ = 0;

        useMakeActive_ = 0;

        useRelocateAndMakeActive_ = 0;

        useMakeInactive_ = 0;

        useMakeChainInactive_ = 0;

        useSwapActive_ = 0;

        useExtendedSwapActive_ = 0;

        useNodePairSwapActive_ = 0;

        usePathLns_ = 0;

        useFullPathLns_ = 0;

        useTspLns_ = 0;

        useInactiveLns_ = 0;

        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_LocalSearchNeighborhoodOperators_descriptor;
      }

      @Override
      public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators getDefaultInstanceForType() {
        return com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.getDefaultInstance();
      }

      @Override
      public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators build() {
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators buildPartial() {
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators result = new com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators(this);
        result.useRelocate_ = useRelocate_;
        result.useRelocatePair_ = useRelocatePair_;
        result.useLightRelocatePair_ = useLightRelocatePair_;
        result.useRelocateNeighbors_ = useRelocateNeighbors_;
        result.useRelocateSubtrip_ = useRelocateSubtrip_;
        result.useExchange_ = useExchange_;
        result.useExchangePair_ = useExchangePair_;
        result.useExchangeSubtrip_ = useExchangeSubtrip_;
        result.useCross_ = useCross_;
        result.useCrossExchange_ = useCrossExchange_;
        result.useRelocateExpensiveChain_ = useRelocateExpensiveChain_;
        result.useTwoOpt_ = useTwoOpt_;
        result.useOrOpt_ = useOrOpt_;
        result.useLinKernighan_ = useLinKernighan_;
        result.useTspOpt_ = useTspOpt_;
        result.useMakeActive_ = useMakeActive_;
        result.useRelocateAndMakeActive_ = useRelocateAndMakeActive_;
        result.useMakeInactive_ = useMakeInactive_;
        result.useMakeChainInactive_ = useMakeChainInactive_;
        result.useSwapActive_ = useSwapActive_;
        result.useExtendedSwapActive_ = useExtendedSwapActive_;
        result.useNodePairSwapActive_ = useNodePairSwapActive_;
        result.usePathLns_ = usePathLns_;
        result.useFullPathLns_ = useFullPathLns_;
        result.useTspLns_ = useTspLns_;
        result.useInactiveLns_ = useInactiveLns_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators) {
          return mergeFrom((com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators other) {
        if (other == com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.getDefaultInstance()) return this;
        if (other.useRelocate_ != 0) {
          setUseRelocateValue(other.getUseRelocateValue());
        }
        if (other.useRelocatePair_ != 0) {
          setUseRelocatePairValue(other.getUseRelocatePairValue());
        }
        if (other.useLightRelocatePair_ != 0) {
          setUseLightRelocatePairValue(other.getUseLightRelocatePairValue());
        }
        if (other.useRelocateNeighbors_ != 0) {
          setUseRelocateNeighborsValue(other.getUseRelocateNeighborsValue());
        }
        if (other.useRelocateSubtrip_ != 0) {
          setUseRelocateSubtripValue(other.getUseRelocateSubtripValue());
        }
        if (other.useExchange_ != 0) {
          setUseExchangeValue(other.getUseExchangeValue());
        }
        if (other.useExchangePair_ != 0) {
          setUseExchangePairValue(other.getUseExchangePairValue());
        }
        if (other.useExchangeSubtrip_ != 0) {
          setUseExchangeSubtripValue(other.getUseExchangeSubtripValue());
        }
        if (other.useCross_ != 0) {
          setUseCrossValue(other.getUseCrossValue());
        }
        if (other.useCrossExchange_ != 0) {
          setUseCrossExchangeValue(other.getUseCrossExchangeValue());
        }
        if (other.useRelocateExpensiveChain_ != 0) {
          setUseRelocateExpensiveChainValue(other.getUseRelocateExpensiveChainValue());
        }
        if (other.useTwoOpt_ != 0) {
          setUseTwoOptValue(other.getUseTwoOptValue());
        }
        if (other.useOrOpt_ != 0) {
          setUseOrOptValue(other.getUseOrOptValue());
        }
        if (other.useLinKernighan_ != 0) {
          setUseLinKernighanValue(other.getUseLinKernighanValue());
        }
        if (other.useTspOpt_ != 0) {
          setUseTspOptValue(other.getUseTspOptValue());
        }
        if (other.useMakeActive_ != 0) {
          setUseMakeActiveValue(other.getUseMakeActiveValue());
        }
        if (other.useRelocateAndMakeActive_ != 0) {
          setUseRelocateAndMakeActiveValue(other.getUseRelocateAndMakeActiveValue());
        }
        if (other.useMakeInactive_ != 0) {
          setUseMakeInactiveValue(other.getUseMakeInactiveValue());
        }
        if (other.useMakeChainInactive_ != 0) {
          setUseMakeChainInactiveValue(other.getUseMakeChainInactiveValue());
        }
        if (other.useSwapActive_ != 0) {
          setUseSwapActiveValue(other.getUseSwapActiveValue());
        }
        if (other.useExtendedSwapActive_ != 0) {
          setUseExtendedSwapActiveValue(other.getUseExtendedSwapActiveValue());
        }
        if (other.useNodePairSwapActive_ != 0) {
          setUseNodePairSwapActiveValue(other.getUseNodePairSwapActiveValue());
        }
        if (other.usePathLns_ != 0) {
          setUsePathLnsValue(other.getUsePathLnsValue());
        }
        if (other.useFullPathLns_ != 0) {
          setUseFullPathLnsValue(other.getUseFullPathLnsValue());
        }
        if (other.useTspLns_ != 0) {
          setUseTspLnsValue(other.getUseTspLnsValue());
        }
        if (other.useInactiveLns_ != 0) {
          setUseInactiveLnsValue(other.getUseInactiveLnsValue());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int useRelocate_ = 0;
      /**
       * <pre>
       * --- Inter-route operators ---
       * Operator which moves a single node to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
       *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
       */
      public int getUseRelocateValue() {
        return useRelocate_;
      }
      /**
       * <pre>
       * --- Inter-route operators ---
       * Operator which moves a single node to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
       *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
       */
      public Builder setUseRelocateValue(int value) {
        useRelocate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Inter-route operators ---
       * Operator which moves a single node to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
       *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseRelocate() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocate_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * --- Inter-route operators ---
       * Operator which moves a single node to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
       *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
       */
      public Builder setUseRelocate(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useRelocate_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Inter-route operators ---
       * Operator which moves a single node to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt;  3  -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt;  3  -&gt;  4  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt;  4  -&gt; [3] -&gt; 5
       *   1 -&gt; [4] -&gt;  2  -&gt;  3  -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate = 1;</code>
       */
      public Builder clearUseRelocate() {
        
        useRelocate_ = 0;
        onChanged();
        return this;
      }

      private int useRelocatePair_ = 0;
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes to another
       * position where the first node of the pair must be before the second node
       * on the same path. Compared to the light_relocate_pair operator, tries all
       * possible positions of insertion of a pair (not only after another pair).
       * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
       * first and last nodes of the path and can therefore not be moved, and
       * (A, B) is a pair of nodes):
       *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
       *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
       */
      public int getUseRelocatePairValue() {
        return useRelocatePair_;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes to another
       * position where the first node of the pair must be before the second node
       * on the same path. Compared to the light_relocate_pair operator, tries all
       * possible positions of insertion of a pair (not only after another pair).
       * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
       * first and last nodes of the path and can therefore not be moved, and
       * (A, B) is a pair of nodes):
       *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
       *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
       */
      public Builder setUseRelocatePairValue(int value) {
        useRelocatePair_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes to another
       * position where the first node of the pair must be before the second node
       * on the same path. Compared to the light_relocate_pair operator, tries all
       * possible positions of insertion of a pair (not only after another pair).
       * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
       * first and last nodes of the path and can therefore not be moved, and
       * (A, B) is a pair of nodes):
       *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
       *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseRelocatePair() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocatePair_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes to another
       * position where the first node of the pair must be before the second node
       * on the same path. Compared to the light_relocate_pair operator, tries all
       * possible positions of insertion of a pair (not only after another pair).
       * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
       * first and last nodes of the path and can therefore not be moved, and
       * (A, B) is a pair of nodes):
       *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
       *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
       */
      public Builder setUseRelocatePair(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useRelocatePair_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes to another
       * position where the first node of the pair must be before the second node
       * on the same path. Compared to the light_relocate_pair operator, tries all
       * possible positions of insertion of a pair (not only after another pair).
       * Possible neighbors for the path 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 (where (1, 3) are
       * first and last nodes of the path and can therefore not be moved, and
       * (A, B) is a pair of nodes):
       *   1 -&gt; [A] -&gt;  2  -&gt; [B] -&gt; 3
       *   1 -&gt;  2  -&gt; [A] -&gt; [B] -&gt; 3
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_pair = 2;</code>
       */
      public Builder clearUseRelocatePair() {
        
        useRelocatePair_ = 0;
        onChanged();
        return this;
      }

      private int useLightRelocatePair_ = 0;
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes after another
       * pair.
       * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
       * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
       * be moved, and (A, B) and (C, D) are pair of nodes):
       *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
       *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
       */
      public int getUseLightRelocatePairValue() {
        return useLightRelocatePair_;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes after another
       * pair.
       * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
       * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
       * be moved, and (A, B) and (C, D) are pair of nodes):
       *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
       *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
       */
      public Builder setUseLightRelocatePairValue(int value) {
        useLightRelocatePair_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes after another
       * pair.
       * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
       * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
       * be moved, and (A, B) and (C, D) are pair of nodes):
       *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
       *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseLightRelocatePair() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useLightRelocatePair_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes after another
       * pair.
       * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
       * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
       * be moved, and (A, B) and (C, D) are pair of nodes):
       *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
       *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
       */
      public Builder setUseLightRelocatePair(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useLightRelocatePair_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which moves a pair of pickup and delivery nodes after another
       * pair.
       * Possible neighbors for paths 1 -&gt; A -&gt; B -&gt; 2, 3 -&gt; C -&gt; D -&gt; 4 (where
       * (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
       * be moved, and (A, B) and (C, D) are pair of nodes):
       *   1 -&gt; 2, 3 -&gt; C -&gt; [A] -&gt; D -&gt; [B] -&gt; 4
       *   1 -&gt; A -&gt; [C] -&gt; B -&gt; [D] -&gt; 2, 3 -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_light_relocate_pair = 24;</code>
       */
      public Builder clearUseLightRelocatePair() {
        
        useLightRelocatePair_ = 0;
        onChanged();
        return this;
      }

      private int useRelocateNeighbors_ = 0;
      /**
       * <pre>
       * Relocate neighborhood which moves chains of neighbors.
       * The operator starts by relocating a node n after a node m, then continues
       * moving nodes which were after n as long as the "cost" added is less than
       * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
       * of next variables, it will try reordering the nodes until it finds a
       * valid path.
       * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
       * are first and last nodes of the path and can therefore not be moved, A
       * must be performed before B, and A, D and E are located at the same
       * place):
       * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
       * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
       * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
       * This operator is extremelly useful to move chains of nodes which are
       * located at the same place (for instance nodes part of a same stop).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
       */
      public int getUseRelocateNeighborsValue() {
        return useRelocateNeighbors_;
      }
      /**
       * <pre>
       * Relocate neighborhood which moves chains of neighbors.
       * The operator starts by relocating a node n after a node m, then continues
       * moving nodes which were after n as long as the "cost" added is less than
       * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
       * of next variables, it will try reordering the nodes until it finds a
       * valid path.
       * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
       * are first and last nodes of the path and can therefore not be moved, A
       * must be performed before B, and A, D and E are located at the same
       * place):
       * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
       * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
       * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
       * This operator is extremelly useful to move chains of nodes which are
       * located at the same place (for instance nodes part of a same stop).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
       */
      public Builder setUseRelocateNeighborsValue(int value) {
        useRelocateNeighbors_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Relocate neighborhood which moves chains of neighbors.
       * The operator starts by relocating a node n after a node m, then continues
       * moving nodes which were after n as long as the "cost" added is less than
       * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
       * of next variables, it will try reordering the nodes until it finds a
       * valid path.
       * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
       * are first and last nodes of the path and can therefore not be moved, A
       * must be performed before B, and A, D and E are located at the same
       * place):
       * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
       * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
       * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
       * This operator is extremelly useful to move chains of nodes which are
       * located at the same place (for instance nodes part of a same stop).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseRelocateNeighbors() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateNeighbors_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Relocate neighborhood which moves chains of neighbors.
       * The operator starts by relocating a node n after a node m, then continues
       * moving nodes which were after n as long as the "cost" added is less than
       * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
       * of next variables, it will try reordering the nodes until it finds a
       * valid path.
       * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
       * are first and last nodes of the path and can therefore not be moved, A
       * must be performed before B, and A, D and E are located at the same
       * place):
       * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
       * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
       * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
       * This operator is extremelly useful to move chains of nodes which are
       * located at the same place (for instance nodes part of a same stop).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
       */
      public Builder setUseRelocateNeighbors(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useRelocateNeighbors_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Relocate neighborhood which moves chains of neighbors.
       * The operator starts by relocating a node n after a node m, then continues
       * moving nodes which were after n as long as the "cost" added is less than
       * the "cost" of the arc (m, n). If the new chain doesn't respect the domain
       * of next variables, it will try reordering the nodes until it finds a
       * valid path.
       * Possible neighbors for path 1 -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; 2 (where (1, 2)
       * are first and last nodes of the path and can therefore not be moved, A
       * must be performed before B, and A, D and E are located at the same
       * place):
       * 1 -&gt; A -&gt; C -&gt; [B] -&gt; D -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; [B] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; C -&gt; D -&gt; E -&gt; [B] -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; [C] -&gt; E -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; D -&gt; E -&gt; [C] -&gt; 2
       * 1 -&gt; A -&gt; [D] -&gt; [E] -&gt; B -&gt; C -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [D] -&gt; [E] -&gt;  C -&gt; 2
       * 1 -&gt; A -&gt; [E] -&gt; B -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; [E] -&gt; C -&gt; D -&gt; 2
       * 1 -&gt; A -&gt; B -&gt; C -&gt; [E] -&gt; D -&gt; 2
       * This operator is extremelly useful to move chains of nodes which are
       * located at the same place (for instance nodes part of a same stop).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_neighbors = 3;</code>
       */
      public Builder clearUseRelocateNeighbors() {
        
        useRelocateNeighbors_ = 0;
        onChanged();
        return this;
      }

      private int useRelocateSubtrip_ = 0;
      /**
       * <pre>
       * Relocate neighborhood that moves subpaths all pickup and delivery
       * pairs have both pickup and delivery inside the subpath or both outside
       * the subpath. For instance, for given paths:
       * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
       * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
       */
      public int getUseRelocateSubtripValue() {
        return useRelocateSubtrip_;
      }
      /**
       * <pre>
       * Relocate neighborhood that moves subpaths all pickup and delivery
       * pairs have both pickup and delivery inside the subpath or both outside
       * the subpath. For instance, for given paths:
       * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
       * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
       */
      public Builder setUseRelocateSubtripValue(int value) {
        useRelocateSubtrip_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Relocate neighborhood that moves subpaths all pickup and delivery
       * pairs have both pickup and delivery inside the subpath or both outside
       * the subpath. For instance, for given paths:
       * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
       * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseRelocateSubtrip() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateSubtrip_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Relocate neighborhood that moves subpaths all pickup and delivery
       * pairs have both pickup and delivery inside the subpath or both outside
       * the subpath. For instance, for given paths:
       * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
       * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
       */
      public Builder setUseRelocateSubtrip(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useRelocateSubtrip_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Relocate neighborhood that moves subpaths all pickup and delivery
       * pairs have both pickup and delivery inside the subpath or both outside
       * the subpath. For instance, for given paths:
       * 0 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
       * 0 -&gt; 5 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 6 -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 8
       * 7 -&gt; 9
       * 0 -&gt; 5 -&gt; 6 -&gt; 8
       * 7 -&gt; A -&gt; B -&gt; A' -&gt; B' -&gt; 9
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_subtrip = 25;</code>
       */
      public Builder clearUseRelocateSubtrip() {
        
        useRelocateSubtrip_ = 0;
        onChanged();
        return this;
      }

      private int useExchange_ = 0;
      /**
       * <pre>
       * Operator which exchanges the positions of two nodes.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
       */
      public int getUseExchangeValue() {
        return useExchange_;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two nodes.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
       */
      public Builder setUseExchangeValue(int value) {
        useExchange_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two nodes.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseExchange() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExchange_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two nodes.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
       */
      public Builder setUseExchange(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useExchange_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two nodes.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5
       *   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5
       *   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange = 4;</code>
       */
      public Builder clearUseExchange() {
        
        useExchange_ = 0;
        onChanged();
        return this;
      }

      private int useExchangePair_ = 0;
      /**
       * <pre>
       * Operator which exchanges the positions of two pair of nodes. Pairs
       * correspond to the pickup and delivery pairs defined in the routing model.
       * Possible neighbor for the paths
       * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
       * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
       * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
       *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
       */
      public int getUseExchangePairValue() {
        return useExchangePair_;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two pair of nodes. Pairs
       * correspond to the pickup and delivery pairs defined in the routing model.
       * Possible neighbor for the paths
       * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
       * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
       * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
       *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
       */
      public Builder setUseExchangePairValue(int value) {
        useExchangePair_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two pair of nodes. Pairs
       * correspond to the pickup and delivery pairs defined in the routing model.
       * Possible neighbor for the paths
       * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
       * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
       * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
       *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseExchangePair() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExchangePair_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two pair of nodes. Pairs
       * correspond to the pickup and delivery pairs defined in the routing model.
       * Possible neighbor for the paths
       * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
       * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
       * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
       *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
       */
      public Builder setUseExchangePair(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useExchangePair_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which exchanges the positions of two pair of nodes. Pairs
       * correspond to the pickup and delivery pairs defined in the routing model.
       * Possible neighbor for the paths
       * 1 -&gt; A -&gt; B -&gt; 2 -&gt; 3 and 4 -&gt; C -&gt; D -&gt; 5
       * (where (1, 3) and (4, 5) are first and last nodes of the paths and can
       * therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
       *   1 -&gt; [C] -&gt;  [D] -&gt; 2 -&gt; 3, 4 -&gt; [A] -&gt; [B] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_pair = 22;</code>
       */
      public Builder clearUseExchangePair() {
        
        useExchangePair_ = 0;
        onChanged();
        return this;
      }

      private int useExchangeSubtrip_ = 0;
      /**
       * <pre>
       * Operator which exchanges subtrips associated to two pairs of nodes,
       * see use_relocate_subtrip for a definition of subtrips.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
       */
      public int getUseExchangeSubtripValue() {
        return useExchangeSubtrip_;
      }
      /**
       * <pre>
       * Operator which exchanges subtrips associated to two pairs of nodes,
       * see use_relocate_subtrip for a definition of subtrips.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
       */
      public Builder setUseExchangeSubtripValue(int value) {
        useExchangeSubtrip_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which exchanges subtrips associated to two pairs of nodes,
       * see use_relocate_subtrip for a definition of subtrips.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseExchangeSubtrip() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExchangeSubtrip_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which exchanges subtrips associated to two pairs of nodes,
       * see use_relocate_subtrip for a definition of subtrips.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
       */
      public Builder setUseExchangeSubtrip(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useExchangeSubtrip_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which exchanges subtrips associated to two pairs of nodes,
       * see use_relocate_subtrip for a definition of subtrips.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_exchange_subtrip = 26;</code>
       */
      public Builder clearUseExchangeSubtrip() {
        
        useExchangeSubtrip_ = 0;
        onChanged();
        return this;
      }

      private int useCross_ = 0;
      /**
       * <pre>
       * Operator which cross exchanges the starting chains of 2 paths, including
       * exchanging the whole paths.
       * First and last nodes are not moved.
       * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
       * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
       * therefore not be moved):
       *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
       *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
       *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
       */
      public int getUseCrossValue() {
        return useCross_;
      }
      /**
       * <pre>
       * Operator which cross exchanges the starting chains of 2 paths, including
       * exchanging the whole paths.
       * First and last nodes are not moved.
       * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
       * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
       * therefore not be moved):
       *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
       *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
       *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
       */
      public Builder setUseCrossValue(int value) {
        useCross_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which cross exchanges the starting chains of 2 paths, including
       * exchanging the whole paths.
       * First and last nodes are not moved.
       * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
       * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
       * therefore not be moved):
       *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
       *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
       *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseCross() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useCross_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which cross exchanges the starting chains of 2 paths, including
       * exchanging the whole paths.
       * First and last nodes are not moved.
       * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
       * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
       * therefore not be moved):
       *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
       *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
       *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
       */
      public Builder setUseCross(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useCross_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which cross exchanges the starting chains of 2 paths, including
       * exchanging the whole paths.
       * First and last nodes are not moved.
       * Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8
       * (where (1, 5) and (6, 8) are first and last nodes of the paths and can
       * therefore not be moved):
       *   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8
       *   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8
       *   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross = 5;</code>
       */
      public Builder clearUseCross() {
        
        useCross_ = 0;
        onChanged();
        return this;
      }

      private int useCrossExchange_ = 0;
      /**
       * <pre>
       * Not implemented yet. TODO(b/68128619): Implement.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
       */
      public int getUseCrossExchangeValue() {
        return useCrossExchange_;
      }
      /**
       * <pre>
       * Not implemented yet. TODO(b/68128619): Implement.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
       */
      public Builder setUseCrossExchangeValue(int value) {
        useCrossExchange_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Not implemented yet. TODO(b/68128619): Implement.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseCrossExchange() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useCrossExchange_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Not implemented yet. TODO(b/68128619): Implement.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
       */
      public Builder setUseCrossExchange(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useCrossExchange_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Not implemented yet. TODO(b/68128619): Implement.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_cross_exchange = 6;</code>
       */
      public Builder clearUseCrossExchange() {
        
        useCrossExchange_ = 0;
        onChanged();
        return this;
      }

      private int useRelocateExpensiveChain_ = 0;
      /**
       * <pre>
       * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
       * most expensive arcs on a path, and moves the chain resulting from cutting
       * pairs of arcs among these to another position.
       * Possible neighbors for paths 1 -&gt; 2 (empty) and
       * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
       * most expensive arcs, and the chain resulting from breaking them is
       * B -&gt; C):
       *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
       */
      public int getUseRelocateExpensiveChainValue() {
        return useRelocateExpensiveChain_;
      }
      /**
       * <pre>
       * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
       * most expensive arcs on a path, and moves the chain resulting from cutting
       * pairs of arcs among these to another position.
       * Possible neighbors for paths 1 -&gt; 2 (empty) and
       * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
       * most expensive arcs, and the chain resulting from breaking them is
       * B -&gt; C):
       *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
       */
      public Builder setUseRelocateExpensiveChainValue(int value) {
        useRelocateExpensiveChain_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
       * most expensive arcs on a path, and moves the chain resulting from cutting
       * pairs of arcs among these to another position.
       * Possible neighbors for paths 1 -&gt; 2 (empty) and
       * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
       * most expensive arcs, and the chain resulting from breaking them is
       * B -&gt; C):
       *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseRelocateExpensiveChain() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateExpensiveChain_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
       * most expensive arcs on a path, and moves the chain resulting from cutting
       * pairs of arcs among these to another position.
       * Possible neighbors for paths 1 -&gt; 2 (empty) and
       * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
       * most expensive arcs, and the chain resulting from breaking them is
       * B -&gt; C):
       *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
       */
      public Builder setUseRelocateExpensiveChain(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useRelocateExpensiveChain_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which detects the relocate_expensive_chain_num_arcs_to_consider
       * most expensive arcs on a path, and moves the chain resulting from cutting
       * pairs of arcs among these to another position.
       * Possible neighbors for paths 1 -&gt; 2 (empty) and
       * 3 -&gt; A ------&gt; B --&gt; C -----&gt; D -&gt; 4 (where A -&gt; B and C -&gt; D are the 2
       * most expensive arcs, and the chain resulting from breaking them is
       * B -&gt; C):
       *   1 -&gt; [B -&gt; C] -&gt; 2     3 -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; [B -&gt; C] -&gt; A -&gt; D -&gt; 4
       *   1 -&gt; 2      3 -&gt; A -&gt; D -&gt; [B -&gt; C] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_expensive_chain = 23;</code>
       */
      public Builder clearUseRelocateExpensiveChain() {
        
        useRelocateExpensiveChain_ = 0;
        onChanged();
        return this;
      }

      private int useTwoOpt_ = 0;
      /**
       * <pre>
       * --- Intra-route operators ---
       * Operator which reverves a sub-chain of a path. It is called TwoOpt
       * because it breaks two arcs on the path; resulting paths are called
       * two-optimal.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
       *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
       *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
       */
      public int getUseTwoOptValue() {
        return useTwoOpt_;
      }
      /**
       * <pre>
       * --- Intra-route operators ---
       * Operator which reverves a sub-chain of a path. It is called TwoOpt
       * because it breaks two arcs on the path; resulting paths are called
       * two-optimal.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
       *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
       *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
       */
      public Builder setUseTwoOptValue(int value) {
        useTwoOpt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Intra-route operators ---
       * Operator which reverves a sub-chain of a path. It is called TwoOpt
       * because it breaks two arcs on the path; resulting paths are called
       * two-optimal.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
       *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
       *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseTwoOpt() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useTwoOpt_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * --- Intra-route operators ---
       * Operator which reverves a sub-chain of a path. It is called TwoOpt
       * because it breaks two arcs on the path; resulting paths are called
       * two-optimal.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
       *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
       *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
       */
      public Builder setUseTwoOpt(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useTwoOpt_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Intra-route operators ---
       * Operator which reverves a sub-chain of a path. It is called TwoOpt
       * because it breaks two arcs on the path; resulting paths are called
       * two-optimal.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
       * (where (1, 5) are first and last nodes of the path and can therefore not
       * be moved):
       *   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5
       *   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5
       *   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_two_opt = 7;</code>
       */
      public Builder clearUseTwoOpt() {
        
        useTwoOpt_ = 0;
        onChanged();
        return this;
      }

      private int useOrOpt_ = 0;
      /**
       * <pre>
       * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
       * position in the same path.
       * When the length of the sub-chain is 1, the operator simply moves a node
       * to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
       * length of 2 (where (1, 5) are first and last nodes of the path and can
       * therefore not be moved):
       *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
       *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
       * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
       * path).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
       */
      public int getUseOrOptValue() {
        return useOrOpt_;
      }
      /**
       * <pre>
       * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
       * position in the same path.
       * When the length of the sub-chain is 1, the operator simply moves a node
       * to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
       * length of 2 (where (1, 5) are first and last nodes of the path and can
       * therefore not be moved):
       *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
       *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
       * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
       * path).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
       */
      public Builder setUseOrOptValue(int value) {
        useOrOpt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
       * position in the same path.
       * When the length of the sub-chain is 1, the operator simply moves a node
       * to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
       * length of 2 (where (1, 5) are first and last nodes of the path and can
       * therefore not be moved):
       *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
       *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
       * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
       * path).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseOrOpt() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useOrOpt_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
       * position in the same path.
       * When the length of the sub-chain is 1, the operator simply moves a node
       * to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
       * length of 2 (where (1, 5) are first and last nodes of the path and can
       * therefore not be moved):
       *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
       *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
       * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
       * path).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
       */
      public Builder setUseOrOpt(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useOrOpt_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which moves sub-chains of a path of length 1, 2 and 3 to another
       * position in the same path.
       * When the length of the sub-chain is 1, the operator simply moves a node
       * to another position.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a sub-chain
       * length of 2 (where (1, 5) are first and last nodes of the path and can
       * therefore not be moved):
       *   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5
       *   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5
       * The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
       * path).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_or_opt = 8;</code>
       */
      public Builder clearUseOrOpt() {
        
        useOrOpt_ = 0;
        onChanged();
        return this;
      }

      private int useLinKernighan_ = 0;
      /**
       * <pre>
       * Lin-Kernighan operator.
       * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
       * move followed by a series of 2-OPT moves. Returns a neighbor for which
       * the global gain is positive.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
       */
      public int getUseLinKernighanValue() {
        return useLinKernighan_;
      }
      /**
       * <pre>
       * Lin-Kernighan operator.
       * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
       * move followed by a series of 2-OPT moves. Returns a neighbor for which
       * the global gain is positive.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
       */
      public Builder setUseLinKernighanValue(int value) {
        useLinKernighan_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Lin-Kernighan operator.
       * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
       * move followed by a series of 2-OPT moves. Returns a neighbor for which
       * the global gain is positive.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseLinKernighan() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useLinKernighan_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Lin-Kernighan operator.
       * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
       * move followed by a series of 2-OPT moves. Returns a neighbor for which
       * the global gain is positive.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
       */
      public Builder setUseLinKernighan(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useLinKernighan_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Lin-Kernighan operator.
       * While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
       * move followed by a series of 2-OPT moves. Returns a neighbor for which
       * the global gain is positive.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_lin_kernighan = 9;</code>
       */
      public Builder clearUseLinKernighan() {
        
        useLinKernighan_ = 0;
        onChanged();
        return this;
      }

      private int useTspOpt_ = 0;
      /**
       * <pre>
       * Sliding TSP operator.
       * Uses an exact dynamic programming algorithm to solve the TSP
       * corresponding to path sub-chains.
       * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
       * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
       * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
       */
      public int getUseTspOptValue() {
        return useTspOpt_;
      }
      /**
       * <pre>
       * Sliding TSP operator.
       * Uses an exact dynamic programming algorithm to solve the TSP
       * corresponding to path sub-chains.
       * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
       * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
       * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
       */
      public Builder setUseTspOptValue(int value) {
        useTspOpt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Sliding TSP operator.
       * Uses an exact dynamic programming algorithm to solve the TSP
       * corresponding to path sub-chains.
       * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
       * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
       * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseTspOpt() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useTspOpt_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Sliding TSP operator.
       * Uses an exact dynamic programming algorithm to solve the TSP
       * corresponding to path sub-chains.
       * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
       * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
       * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
       */
      public Builder setUseTspOpt(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useTspOpt_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Sliding TSP operator.
       * Uses an exact dynamic programming algorithm to solve the TSP
       * corresponding to path sub-chains.
       * For a subchain 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, solves the TSP on
       * nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
       * cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_opt = 10;</code>
       */
      public Builder clearUseTspOpt() {
        
        useTspOpt_ = 0;
        onChanged();
        return this;
      }

      private int useMakeActive_ = 0;
      /**
       * <pre>
       * --- Operators on inactive nodes ---
       * Operator which inserts an inactive node into a path.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
       */
      public int getUseMakeActiveValue() {
        return useMakeActive_;
      }
      /**
       * <pre>
       * --- Operators on inactive nodes ---
       * Operator which inserts an inactive node into a path.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
       */
      public Builder setUseMakeActiveValue(int value) {
        useMakeActive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Operators on inactive nodes ---
       * Operator which inserts an inactive node into a path.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseMakeActive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useMakeActive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * --- Operators on inactive nodes ---
       * Operator which inserts an inactive node into a path.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
       */
      public Builder setUseMakeActive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useMakeActive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Operators on inactive nodes ---
       * Operator which inserts an inactive node into a path.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4
       *   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_active = 11;</code>
       */
      public Builder clearUseMakeActive() {
        
        useMakeActive_ = 0;
        onChanged();
        return this;
      }

      private int useRelocateAndMakeActive_ = 0;
      /**
       * <pre>
       * Operator which relocates a node while making an inactive one active.
       * As of 3/2017, the operator is limited to two kinds of moves:
       * - Relocating a node and replacing it by an inactive node.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
       * - Relocating a node and inserting an inactive node next to it.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
       */
      public int getUseRelocateAndMakeActiveValue() {
        return useRelocateAndMakeActive_;
      }
      /**
       * <pre>
       * Operator which relocates a node while making an inactive one active.
       * As of 3/2017, the operator is limited to two kinds of moves:
       * - Relocating a node and replacing it by an inactive node.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
       * - Relocating a node and inserting an inactive node next to it.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
       */
      public Builder setUseRelocateAndMakeActiveValue(int value) {
        useRelocateAndMakeActive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which relocates a node while making an inactive one active.
       * As of 3/2017, the operator is limited to two kinds of moves:
       * - Relocating a node and replacing it by an inactive node.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
       * - Relocating a node and inserting an inactive node next to it.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseRelocateAndMakeActive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useRelocateAndMakeActive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which relocates a node while making an inactive one active.
       * As of 3/2017, the operator is limited to two kinds of moves:
       * - Relocating a node and replacing it by an inactive node.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
       * - Relocating a node and inserting an inactive node next to it.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
       */
      public Builder setUseRelocateAndMakeActive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useRelocateAndMakeActive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which relocates a node while making an inactive one active.
       * As of 3/2017, the operator is limited to two kinds of moves:
       * - Relocating a node and replacing it by an inactive node.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 3 -&gt; 5, 2 -&gt; 4 -&gt; 6.
       * - Relocating a node and inserting an inactive node next to it.
       *   Possible neighbor for path 1 -&gt; 5, 2 -&gt; 3 -&gt; 6 and 4 inactive
       *   (where 1,2 and 5,6 are first and last nodes of paths) is:
       *   1 -&gt; 4 -&gt; 3 -&gt; 5, 2 -&gt; 6.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_relocate_and_make_active = 21;</code>
       */
      public Builder clearUseRelocateAndMakeActive() {
        
        useRelocateAndMakeActive_ = 0;
        onChanged();
        return this;
      }

      private int useMakeInactive_ = 0;
      /**
       * <pre>
       * Operator which makes path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
       */
      public int getUseMakeInactiveValue() {
        return useMakeInactive_;
      }
      /**
       * <pre>
       * Operator which makes path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
       */
      public Builder setUseMakeInactiveValue(int value) {
        useMakeInactive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseMakeInactive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useMakeInactive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which makes path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
       */
      public Builder setUseMakeInactive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useMakeInactive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_inactive = 12;</code>
       */
      public Builder clearUseMakeInactive() {
        
        useMakeInactive_ = 0;
        onChanged();
        return this;
      }

      private int useMakeChainInactive_ = 0;
      /**
       * <pre>
       * Operator which makes a "chain" of path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       *   1 -&gt; 4 with 2 and 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
       */
      public int getUseMakeChainInactiveValue() {
        return useMakeChainInactive_;
      }
      /**
       * <pre>
       * Operator which makes a "chain" of path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       *   1 -&gt; 4 with 2 and 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
       */
      public Builder setUseMakeChainInactiveValue(int value) {
        useMakeChainInactive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes a "chain" of path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       *   1 -&gt; 4 with 2 and 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseMakeChainInactive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useMakeChainInactive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which makes a "chain" of path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       *   1 -&gt; 4 with 2 and 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
       */
      public Builder setUseMakeChainInactive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useMakeChainInactive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes a "chain" of path nodes inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first
       * and last nodes of the path) are:
       *   1 -&gt; 3 -&gt; 4 with 2 inactive
       *   1 -&gt; 2 -&gt; 4 with 3 inactive
       *   1 -&gt; 4 with 2 and 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_make_chain_inactive = 13;</code>
       */
      public Builder clearUseMakeChainInactive() {
        
        useMakeChainInactive_ = 0;
        onChanged();
        return this;
      }

      private int useSwapActive_ = 0;
      /**
       * <pre>
       * Operator which replaces an active node by an inactive one.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
       */
      public int getUseSwapActiveValue() {
        return useSwapActive_;
      }
      /**
       * <pre>
       * Operator which replaces an active node by an inactive one.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
       */
      public Builder setUseSwapActiveValue(int value) {
        useSwapActive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which replaces an active node by an inactive one.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseSwapActive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useSwapActive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which replaces an active node by an inactive one.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
       */
      public Builder setUseSwapActive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useSwapActive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which replaces an active node by an inactive one.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_swap_active = 14;</code>
       */
      public Builder clearUseSwapActive() {
        
        useSwapActive_ = 0;
        onChanged();
        return this;
      }

      private int useExtendedSwapActive_ = 0;
      /**
       * <pre>
       * Operator which makes an inactive node active and an active one inactive.
       * It is similar to SwapActiveOperator excepts that it tries to insert the
       * inactive node in all possible positions instead of just the position of
       * the node made inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
       *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
       */
      public int getUseExtendedSwapActiveValue() {
        return useExtendedSwapActive_;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active one inactive.
       * It is similar to SwapActiveOperator excepts that it tries to insert the
       * inactive node in all possible positions instead of just the position of
       * the node made inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
       *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
       */
      public Builder setUseExtendedSwapActiveValue(int value) {
        useExtendedSwapActive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active one inactive.
       * It is similar to SwapActiveOperator excepts that it tries to insert the
       * inactive node in all possible positions instead of just the position of
       * the node made inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
       *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseExtendedSwapActive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useExtendedSwapActive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active one inactive.
       * It is similar to SwapActiveOperator excepts that it tries to insert the
       * inactive node in all possible positions instead of just the position of
       * the node made inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
       *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
       */
      public Builder setUseExtendedSwapActive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useExtendedSwapActive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active one inactive.
       * It is similar to SwapActiveOperator excepts that it tries to insert the
       * inactive node in all possible positions instead of just the position of
       * the node made inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path) are:
       *   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive
       *   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive
       *   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive
       *   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_extended_swap_active = 15;</code>
       */
      public Builder clearUseExtendedSwapActive() {
        
        useExtendedSwapActive_ = 0;
        onChanged();
        return this;
      }

      private int useNodePairSwapActive_ = 0;
      /**
       * <pre>
       * Operator which makes an inactive node active and an active pair of nodes
       * inactive OR makes an inactive pair of nodes active and an active node
       * inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
       * of nodes) are:
       *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
       * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
       * of nodes) are:
       *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
       */
      public int getUseNodePairSwapActiveValue() {
        return useNodePairSwapActive_;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active pair of nodes
       * inactive OR makes an inactive pair of nodes active and an active node
       * inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
       * of nodes) are:
       *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
       * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
       * of nodes) are:
       *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
       */
      public Builder setUseNodePairSwapActiveValue(int value) {
        useNodePairSwapActive_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active pair of nodes
       * inactive OR makes an inactive pair of nodes active and an active node
       * inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
       * of nodes) are:
       *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
       * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
       * of nodes) are:
       *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseNodePairSwapActive() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useNodePairSwapActive_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active pair of nodes
       * inactive OR makes an inactive pair of nodes active and an active node
       * inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
       * of nodes) are:
       *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
       * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
       * of nodes) are:
       *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
       */
      public Builder setUseNodePairSwapActive(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useNodePairSwapActive_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which makes an inactive node active and an active pair of nodes
       * inactive OR makes an inactive pair of nodes active and an active node
       * inactive.
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive
       * (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
       * of nodes) are:
       *   1 -&gt; [5] -&gt; 4 with (2,3) inactive
       * Possible neighbors for the path 1 -&gt; 2 -&gt; 3 with (4,5) inactive
       * (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
       * of nodes) are:
       *   1 -&gt; [4] -&gt; [5] -&gt; 3 with 2 inactive
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_node_pair_swap_active = 20;</code>
       */
      public Builder clearUseNodePairSwapActive() {
        
        useNodePairSwapActive_ = 0;
        onChanged();
        return this;
      }

      private int usePathLns_ = 0;
      /**
       * <pre>
       * --- Large neighborhood search operators ---
       * Operator which relaxes two sub-chains of three consecutive arcs each.
       * Each sub-chain is defined by a start node and the next three arcs. Those
       * six arcs are relaxed to build a new neighbor.
       * PATH_LNS explores all possible pairs of starting nodes and so defines
       * n^2 neighbors, n being the number of nodes.
       * Note that the two sub-chains can be part of the same path; they even may
       * overlap.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
       */
      public int getUsePathLnsValue() {
        return usePathLns_;
      }
      /**
       * <pre>
       * --- Large neighborhood search operators ---
       * Operator which relaxes two sub-chains of three consecutive arcs each.
       * Each sub-chain is defined by a start node and the next three arcs. Those
       * six arcs are relaxed to build a new neighbor.
       * PATH_LNS explores all possible pairs of starting nodes and so defines
       * n^2 neighbors, n being the number of nodes.
       * Note that the two sub-chains can be part of the same path; they even may
       * overlap.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
       */
      public Builder setUsePathLnsValue(int value) {
        usePathLns_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Large neighborhood search operators ---
       * Operator which relaxes two sub-chains of three consecutive arcs each.
       * Each sub-chain is defined by a start node and the next three arcs. Those
       * six arcs are relaxed to build a new neighbor.
       * PATH_LNS explores all possible pairs of starting nodes and so defines
       * n^2 neighbors, n being the number of nodes.
       * Note that the two sub-chains can be part of the same path; they even may
       * overlap.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUsePathLns() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(usePathLns_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * --- Large neighborhood search operators ---
       * Operator which relaxes two sub-chains of three consecutive arcs each.
       * Each sub-chain is defined by a start node and the next three arcs. Those
       * six arcs are relaxed to build a new neighbor.
       * PATH_LNS explores all possible pairs of starting nodes and so defines
       * n^2 neighbors, n being the number of nodes.
       * Note that the two sub-chains can be part of the same path; they even may
       * overlap.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
       */
      public Builder setUsePathLns(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        usePathLns_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * --- Large neighborhood search operators ---
       * Operator which relaxes two sub-chains of three consecutive arcs each.
       * Each sub-chain is defined by a start node and the next three arcs. Those
       * six arcs are relaxed to build a new neighbor.
       * PATH_LNS explores all possible pairs of starting nodes and so defines
       * n^2 neighbors, n being the number of nodes.
       * Note that the two sub-chains can be part of the same path; they even may
       * overlap.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_path_lns = 16;</code>
       */
      public Builder clearUsePathLns() {
        
        usePathLns_ = 0;
        onChanged();
        return this;
      }

      private int useFullPathLns_ = 0;
      /**
       * <pre>
       * Operator which relaxes one entire path and all unactive nodes.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
       */
      public int getUseFullPathLnsValue() {
        return useFullPathLns_;
      }
      /**
       * <pre>
       * Operator which relaxes one entire path and all unactive nodes.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
       */
      public Builder setUseFullPathLnsValue(int value) {
        useFullPathLns_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which relaxes one entire path and all unactive nodes.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseFullPathLns() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useFullPathLns_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which relaxes one entire path and all unactive nodes.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
       */
      public Builder setUseFullPathLns(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useFullPathLns_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which relaxes one entire path and all unactive nodes.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_full_path_lns = 17;</code>
       */
      public Builder clearUseFullPathLns() {
        
        useFullPathLns_ = 0;
        onChanged();
        return this;
      }

      private int useTspLns_ = 0;
      /**
       * <pre>
       * TSP-base LNS.
       * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
       * the corresponding TSP.
       * This defines an "unlimited" neighborhood which must be stopped by search
       * limits. To force diversification, the operator iteratively forces each
       * node to serve as base of a meta-node.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
       */
      public int getUseTspLnsValue() {
        return useTspLns_;
      }
      /**
       * <pre>
       * TSP-base LNS.
       * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
       * the corresponding TSP.
       * This defines an "unlimited" neighborhood which must be stopped by search
       * limits. To force diversification, the operator iteratively forces each
       * node to serve as base of a meta-node.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
       */
      public Builder setUseTspLnsValue(int value) {
        useTspLns_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TSP-base LNS.
       * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
       * the corresponding TSP.
       * This defines an "unlimited" neighborhood which must be stopped by search
       * limits. To force diversification, the operator iteratively forces each
       * node to serve as base of a meta-node.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseTspLns() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useTspLns_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * TSP-base LNS.
       * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
       * the corresponding TSP.
       * This defines an "unlimited" neighborhood which must be stopped by search
       * limits. To force diversification, the operator iteratively forces each
       * node to serve as base of a meta-node.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
       */
      public Builder setUseTspLns(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useTspLns_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TSP-base LNS.
       * Randomly merges consecutive nodes until n "meta"-nodes remain and solves
       * the corresponding TSP.
       * This defines an "unlimited" neighborhood which must be stopped by search
       * limits. To force diversification, the operator iteratively forces each
       * node to serve as base of a meta-node.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_tsp_lns = 18;</code>
       */
      public Builder clearUseTspLns() {
        
        useTspLns_ = 0;
        onChanged();
        return this;
      }

      private int useInactiveLns_ = 0;
      /**
       * <pre>
       * Operator which relaxes all inactive nodes and one sub-chain of six
       * consecutive arcs. That way the path can be improved by inserting inactive
       * nodes or swaping arcs.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
       */
      public int getUseInactiveLnsValue() {
        return useInactiveLns_;
      }
      /**
       * <pre>
       * Operator which relaxes all inactive nodes and one sub-chain of six
       * consecutive arcs. That way the path can be improved by inserting inactive
       * nodes or swaping arcs.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
       */
      public Builder setUseInactiveLnsValue(int value) {
        useInactiveLns_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which relaxes all inactive nodes and one sub-chain of six
       * consecutive arcs. That way the path can be improved by inserting inactive
       * nodes or swaping arcs.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
       */
      public com.google.ortools.util.OptionalBoolean getUseInactiveLns() {
        @SuppressWarnings("deprecation")
        com.google.ortools.util.OptionalBoolean result = com.google.ortools.util.OptionalBoolean.valueOf(useInactiveLns_);
        return result == null ? com.google.ortools.util.OptionalBoolean.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Operator which relaxes all inactive nodes and one sub-chain of six
       * consecutive arcs. That way the path can be improved by inserting inactive
       * nodes or swaping arcs.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
       */
      public Builder setUseInactiveLns(com.google.ortools.util.OptionalBoolean value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        useInactiveLns_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operator which relaxes all inactive nodes and one sub-chain of six
       * consecutive arcs. That way the path can be improved by inserting inactive
       * nodes or swaping arcs.
       * </pre>
       *
       * <code>.operations_research.OptionalBoolean use_inactive_lns = 19;</code>
       */
      public Builder clearUseInactiveLns() {
        
        useInactiveLns_ = 0;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators)
    }

    // @@protoc_insertion_point(class_scope:operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators)
    private static final com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators();
    }

    public static com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LocalSearchNeighborhoodOperators>
        PARSER = new com.google.protobuf.AbstractParser<LocalSearchNeighborhoodOperators>() {
      @Override
      public LocalSearchNeighborhoodOperators parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new LocalSearchNeighborhoodOperators(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<LocalSearchNeighborhoodOperators> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<LocalSearchNeighborhoodOperators> getParserForType() {
      return PARSER;
    }

    @Override
    public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public static final int FIRST_SOLUTION_STRATEGY_FIELD_NUMBER = 1;
  private int firstSolutionStrategy_;
  /**
   * <pre>
   * First solution strategies, used as starting point of local search.
   * </pre>
   *
   * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
   */
  public int getFirstSolutionStrategyValue() {
    return firstSolutionStrategy_;
  }
  /**
   * <pre>
   * First solution strategies, used as starting point of local search.
   * </pre>
   *
   * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
   */
  public com.google.ortools.constraintsolver.FirstSolutionStrategy.Value getFirstSolutionStrategy() {
    @SuppressWarnings("deprecation")
    com.google.ortools.constraintsolver.FirstSolutionStrategy.Value result = com.google.ortools.constraintsolver.FirstSolutionStrategy.Value.valueOf(firstSolutionStrategy_);
    return result == null ? com.google.ortools.constraintsolver.FirstSolutionStrategy.Value.UNRECOGNIZED : result;
  }

  public static final int USE_UNFILTERED_FIRST_SOLUTION_STRATEGY_FIELD_NUMBER = 2;
  private boolean useUnfilteredFirstSolutionStrategy_;
  /**
   * <pre>
   * --- Advanced first solutions strategy settings ---
   * Don't touch these unless you know what you are doing.
   * Use filtered version of first solution strategy if available.
   * </pre>
   *
   * <code>bool use_unfiltered_first_solution_strategy = 2;</code>
   */
  public boolean getUseUnfilteredFirstSolutionStrategy() {
    return useUnfilteredFirstSolutionStrategy_;
  }

  public static final int SAVINGS_NEIGHBORS_RATIO_FIELD_NUMBER = 14;
  private double savingsNeighborsRatio_;
  /**
   * <pre>
   * Parameters specific to the Savings first solution heuristic.
   * Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
   * the savings. If unspecified, its value is considered to be 1.0.
   * </pre>
   *
   * <code>double savings_neighbors_ratio = 14;</code>
   */
  public double getSavingsNeighborsRatio() {
    return savingsNeighborsRatio_;
  }

  public static final int SAVINGS_MAX_MEMORY_USAGE_BYTES_FIELD_NUMBER = 23;
  private double savingsMaxMemoryUsageBytes_;
  /**
   * <pre>
   * The number of neighbors considered for each node in the Savings heuristic
   * is chosen so that the space used to store the savings doesn't exceed
   * savings_max_memory_usage_bytes, which must be in ]0, 1e10].
   * NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
   * are specified, the number of neighbors considered for each node will be the
   * minimum of the two numbers determined by these parameters.
   * </pre>
   *
   * <code>double savings_max_memory_usage_bytes = 23;</code>
   */
  public double getSavingsMaxMemoryUsageBytes() {
    return savingsMaxMemoryUsageBytes_;
  }

  public static final int SAVINGS_ADD_REVERSE_ARCS_FIELD_NUMBER = 15;
  private boolean savingsAddReverseArcs_;
  /**
   * <pre>
   * Add savings related to reverse arcs when finding the nearest neighbors
   * of the nodes.
   * </pre>
   *
   * <code>bool savings_add_reverse_arcs = 15;</code>
   */
  public boolean getSavingsAddReverseArcs() {
    return savingsAddReverseArcs_;
  }

  public static final int SAVINGS_ARC_COEFFICIENT_FIELD_NUMBER = 18;
  private double savingsArcCoefficient_;
  /**
   * <pre>
   * Coefficient of the cost of the arc for which the saving value is being
   * computed:
   * Saving(a--&gt;b) = Cost(a--&gt;end) + Cost(start--&gt;b)
   *                 - savings_arc_coefficient * Cost(a--&gt;b)
   * This parameter must be greater than 0, and its default value is 1.
   * </pre>
   *
   * <code>double savings_arc_coefficient = 18;</code>
   */
  public double getSavingsArcCoefficient() {
    return savingsArcCoefficient_;
  }

  public static final int SAVINGS_PARALLEL_ROUTES_FIELD_NUMBER = 19;
  private boolean savingsParallelRoutes_;
  /**
   * <pre>
   * When true, the routes are built in parallel, sequentially otherwise.
   * </pre>
   *
   * <code>bool savings_parallel_routes = 19;</code>
   */
  public boolean getSavingsParallelRoutes() {
    return savingsParallelRoutes_;
  }

  public static final int CHEAPEST_INSERTION_FARTHEST_SEEDS_RATIO_FIELD_NUMBER = 16;
  private double cheapestInsertionFarthestSeedsRatio_;
  /**
   * <pre>
   * Ratio (between 0 and 1) of available vehicles in the model on which
   * farthest nodes of the model are inserted as seeds in the
   * GlobalCheapestInsertion first solution heuristic.
   * </pre>
   *
   * <code>double cheapest_insertion_farthest_seeds_ratio = 16;</code>
   */
  public double getCheapestInsertionFarthestSeedsRatio() {
    return cheapestInsertionFarthestSeedsRatio_;
  }

  public static final int CHEAPEST_INSERTION_NEIGHBORS_RATIO_FIELD_NUMBER = 21;
  private double cheapestInsertionNeighborsRatio_;
  /**
   * <pre>
   * Ratio (in ]0, 1]) of neighbors to consider for each node when creating
   * new insertions in the parallel/sequential cheapest insertion heuristic.
   * If not overridden, its default value is 1, meaning all neighbors will be
   * considered.
   * </pre>
   *
   * <code>double cheapest_insertion_neighbors_ratio = 21;</code>
   */
  public double getCheapestInsertionNeighborsRatio() {
    return cheapestInsertionNeighborsRatio_;
  }

  public static final int LOCAL_SEARCH_OPERATORS_FIELD_NUMBER = 3;
  private com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators localSearchOperators_;
  /**
   * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
   */
  public boolean hasLocalSearchOperators() {
    return localSearchOperators_ != null;
  }
  /**
   * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
   */
  public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators getLocalSearchOperators() {
    return localSearchOperators_ == null ? com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.getDefaultInstance() : localSearchOperators_;
  }
  /**
   * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
   */
  public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder getLocalSearchOperatorsOrBuilder() {
    return getLocalSearchOperators();
  }

  public static final int RELOCATE_EXPENSIVE_CHAIN_NUM_ARCS_TO_CONSIDER_FIELD_NUMBER = 20;
  private int relocateExpensiveChainNumArcsToConsider_;
  /**
   * <pre>
   * Number of expensive arcs to consider cutting in the RelocateExpensiveChain
   * neighborhood operator (see
   * LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
   * This parameter must be greater than 2.
   * NOTE(user): The number of neighbors generated by the operator for
   * relocate_expensive_chain_num_arcs_to_consider = K is around
   * K*(K-1)/2 * number_of_routes * number_of_nodes.
   * </pre>
   *
   * <code>int32 relocate_expensive_chain_num_arcs_to_consider = 20;</code>
   */
  public int getRelocateExpensiveChainNumArcsToConsider() {
    return relocateExpensiveChainNumArcsToConsider_;
  }

  public static final int LOCAL_SEARCH_METAHEURISTIC_FIELD_NUMBER = 4;
  private int localSearchMetaheuristic_;
  /**
   * <pre>
   * Local search metaheuristics used to guide the search.
   * </pre>
   *
   * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
   */
  public int getLocalSearchMetaheuristicValue() {
    return localSearchMetaheuristic_;
  }
  /**
   * <pre>
   * Local search metaheuristics used to guide the search.
   * </pre>
   *
   * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
   */
  public com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value getLocalSearchMetaheuristic() {
    @SuppressWarnings("deprecation")
    com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value result = com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value.valueOf(localSearchMetaheuristic_);
    return result == null ? com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value.UNRECOGNIZED : result;
  }

  public static final int GUIDED_LOCAL_SEARCH_LAMBDA_COEFFICIENT_FIELD_NUMBER = 5;
  private double guidedLocalSearchLambdaCoefficient_;
  /**
   * <pre>
   * These are advanced settings which should not be modified unless you know
   * what you are doing.
   * Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
   * used. Must be positive.
   * </pre>
   *
   * <code>double guided_local_search_lambda_coefficient = 5;</code>
   */
  public double getGuidedLocalSearchLambdaCoefficient() {
    return guidedLocalSearchLambdaCoefficient_;
  }

  public static final int USE_DEPTH_FIRST_SEARCH_FIELD_NUMBER = 6;
  private boolean useDepthFirstSearch_;
  /**
   * <pre>
   * --- Search control ---
   * If true, the solver should use depth-first search rather than local search
   * to solve the problem.
   * </pre>
   *
   * <code>bool use_depth_first_search = 6;</code>
   */
  public boolean getUseDepthFirstSearch() {
    return useDepthFirstSearch_;
  }

  public static final int OPTIMIZATION_STEP_FIELD_NUMBER = 7;
  private double optimizationStep_;
  /**
   * <pre>
   * Minimum step by which the solution must be improved in local search. 0
   * means "unspecified". If this value is fractional, it will get rounded to
   * the nearest integer.
   * </pre>
   *
   * <code>double optimization_step = 7;</code>
   */
  public double getOptimizationStep() {
    return optimizationStep_;
  }

  public static final int NUMBER_OF_SOLUTIONS_TO_COLLECT_FIELD_NUMBER = 17;
  private int numberOfSolutionsToCollect_;
  /**
   * <pre>
   * Number of solutions to collect during the search. Corresponds to the best
   * solutions found during the search. 0 means "unspecified".
   * </pre>
   *
   * <code>int32 number_of_solutions_to_collect = 17;</code>
   */
  public int getNumberOfSolutionsToCollect() {
    return numberOfSolutionsToCollect_;
  }

  public static final int SOLUTION_LIMIT_FIELD_NUMBER = 8;
  private long solutionLimit_;
  /**
   * <pre>
   * -- Search limits --
   * Limit to the number of solutions generated during the search. 0 means
   * "unspecified".
   * </pre>
   *
   * <code>int64 solution_limit = 8;</code>
   */
  public long getSolutionLimit() {
    return solutionLimit_;
  }

  public static final int TIME_LIMIT_FIELD_NUMBER = 9;
  private com.google.protobuf.Duration timeLimit_;
  /**
   * <pre>
   * Limit to the time spent in the search.
   * </pre>
   *
   * <code>.google.protobuf.Duration time_limit = 9;</code>
   */
  public boolean hasTimeLimit() {
    return timeLimit_ != null;
  }
  /**
   * <pre>
   * Limit to the time spent in the search.
   * </pre>
   *
   * <code>.google.protobuf.Duration time_limit = 9;</code>
   */
  public com.google.protobuf.Duration getTimeLimit() {
    return timeLimit_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeLimit_;
  }
  /**
   * <pre>
   * Limit to the time spent in the search.
   * </pre>
   *
   * <code>.google.protobuf.Duration time_limit = 9;</code>
   */
  public com.google.protobuf.DurationOrBuilder getTimeLimitOrBuilder() {
    return getTimeLimit();
  }

  public static final int LNS_TIME_LIMIT_FIELD_NUMBER = 10;
  private com.google.protobuf.Duration lnsTimeLimit_;
  /**
   * <pre>
   * Limit to the time spent in the completion search for each local search
   * neighbor.
   * </pre>
   *
   * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
   */
  public boolean hasLnsTimeLimit() {
    return lnsTimeLimit_ != null;
  }
  /**
   * <pre>
   * Limit to the time spent in the completion search for each local search
   * neighbor.
   * </pre>
   *
   * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
   */
  public com.google.protobuf.Duration getLnsTimeLimit() {
    return lnsTimeLimit_ == null ? com.google.protobuf.Duration.getDefaultInstance() : lnsTimeLimit_;
  }
  /**
   * <pre>
   * Limit to the time spent in the completion search for each local search
   * neighbor.
   * </pre>
   *
   * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
   */
  public com.google.protobuf.DurationOrBuilder getLnsTimeLimitOrBuilder() {
    return getLnsTimeLimit();
  }

  public static final int USE_FULL_PROPAGATION_FIELD_NUMBER = 11;
  private boolean useFullPropagation_;
  /**
   * <pre>
   * --- Propagation control ---
   * These are advanced settings which should not be modified unless you know
   * what you are doing.
   * Use constraints with full propagation in routing model (instead of 'light'
   * propagation only). Full propagation is only necessary when using
   * depth-first search or for models which require strong propagation to
   * finalize the value of secondary variables.
   * Changing this setting to true will slow down the search in most cases and
   * increase memory consumption in all cases.
   * </pre>
   *
   * <code>bool use_full_propagation = 11;</code>
   */
  public boolean getUseFullPropagation() {
    return useFullPropagation_;
  }

  public static final int LOG_SEARCH_FIELD_NUMBER = 13;
  private boolean logSearch_;
  /**
   * <pre>
   * --- Miscellaneous ---
   * Some of these are advanced settings which should not be modified unless you
   * know what you are doing.
   * Activates search logging. For each solution found during the search, the
   * following will be displayed: its objective value, the maximum objective
   * value since the beginning of the search, the elapsed time since the
   * beginning of the search, the number of branches explored in the search
   * tree, the number of failures in the search tree, the depth of the search
   * tree, the number of local search neighbors explored, the number of local
   * search neighbors filtered by local search filters, the number of local
   * search neighbors accepted, the total memory used and the percentage of the
   * search done.
   * </pre>
   *
   * <code>bool log_search = 13;</code>
   */
  public boolean getLogSearch() {
    return logSearch_;
  }

  public static final int LOG_COST_SCALING_FACTOR_FIELD_NUMBER = 22;
  private double logCostScalingFactor_;
  /**
   * <pre>
   * In logs, cost values will be unscaled by this factor.
   * </pre>
   *
   * <code>double log_cost_scaling_factor = 22;</code>
   */
  public double getLogCostScalingFactor() {
    return logCostScalingFactor_;
  }

  private byte memoizedIsInitialized = -1;
  @Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (firstSolutionStrategy_ != com.google.ortools.constraintsolver.FirstSolutionStrategy.Value.UNSET.getNumber()) {
      output.writeEnum(1, firstSolutionStrategy_);
    }
    if (useUnfilteredFirstSolutionStrategy_ != false) {
      output.writeBool(2, useUnfilteredFirstSolutionStrategy_);
    }
    if (localSearchOperators_ != null) {
      output.writeMessage(3, getLocalSearchOperators());
    }
    if (localSearchMetaheuristic_ != com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value.UNSET.getNumber()) {
      output.writeEnum(4, localSearchMetaheuristic_);
    }
    if (guidedLocalSearchLambdaCoefficient_ != 0D) {
      output.writeDouble(5, guidedLocalSearchLambdaCoefficient_);
    }
    if (useDepthFirstSearch_ != false) {
      output.writeBool(6, useDepthFirstSearch_);
    }
    if (optimizationStep_ != 0D) {
      output.writeDouble(7, optimizationStep_);
    }
    if (solutionLimit_ != 0L) {
      output.writeInt64(8, solutionLimit_);
    }
    if (timeLimit_ != null) {
      output.writeMessage(9, getTimeLimit());
    }
    if (lnsTimeLimit_ != null) {
      output.writeMessage(10, getLnsTimeLimit());
    }
    if (useFullPropagation_ != false) {
      output.writeBool(11, useFullPropagation_);
    }
    if (logSearch_ != false) {
      output.writeBool(13, logSearch_);
    }
    if (savingsNeighborsRatio_ != 0D) {
      output.writeDouble(14, savingsNeighborsRatio_);
    }
    if (savingsAddReverseArcs_ != false) {
      output.writeBool(15, savingsAddReverseArcs_);
    }
    if (cheapestInsertionFarthestSeedsRatio_ != 0D) {
      output.writeDouble(16, cheapestInsertionFarthestSeedsRatio_);
    }
    if (numberOfSolutionsToCollect_ != 0) {
      output.writeInt32(17, numberOfSolutionsToCollect_);
    }
    if (savingsArcCoefficient_ != 0D) {
      output.writeDouble(18, savingsArcCoefficient_);
    }
    if (savingsParallelRoutes_ != false) {
      output.writeBool(19, savingsParallelRoutes_);
    }
    if (relocateExpensiveChainNumArcsToConsider_ != 0) {
      output.writeInt32(20, relocateExpensiveChainNumArcsToConsider_);
    }
    if (cheapestInsertionNeighborsRatio_ != 0D) {
      output.writeDouble(21, cheapestInsertionNeighborsRatio_);
    }
    if (logCostScalingFactor_ != 0D) {
      output.writeDouble(22, logCostScalingFactor_);
    }
    if (savingsMaxMemoryUsageBytes_ != 0D) {
      output.writeDouble(23, savingsMaxMemoryUsageBytes_);
    }
    unknownFields.writeTo(output);
  }

  @Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (firstSolutionStrategy_ != com.google.ortools.constraintsolver.FirstSolutionStrategy.Value.UNSET.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(1, firstSolutionStrategy_);
    }
    if (useUnfilteredFirstSolutionStrategy_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(2, useUnfilteredFirstSolutionStrategy_);
    }
    if (localSearchOperators_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, getLocalSearchOperators());
    }
    if (localSearchMetaheuristic_ != com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value.UNSET.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(4, localSearchMetaheuristic_);
    }
    if (guidedLocalSearchLambdaCoefficient_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(5, guidedLocalSearchLambdaCoefficient_);
    }
    if (useDepthFirstSearch_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(6, useDepthFirstSearch_);
    }
    if (optimizationStep_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(7, optimizationStep_);
    }
    if (solutionLimit_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(8, solutionLimit_);
    }
    if (timeLimit_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getTimeLimit());
    }
    if (lnsTimeLimit_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(10, getLnsTimeLimit());
    }
    if (useFullPropagation_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(11, useFullPropagation_);
    }
    if (logSearch_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(13, logSearch_);
    }
    if (savingsNeighborsRatio_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(14, savingsNeighborsRatio_);
    }
    if (savingsAddReverseArcs_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(15, savingsAddReverseArcs_);
    }
    if (cheapestInsertionFarthestSeedsRatio_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(16, cheapestInsertionFarthestSeedsRatio_);
    }
    if (numberOfSolutionsToCollect_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(17, numberOfSolutionsToCollect_);
    }
    if (savingsArcCoefficient_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(18, savingsArcCoefficient_);
    }
    if (savingsParallelRoutes_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(19, savingsParallelRoutes_);
    }
    if (relocateExpensiveChainNumArcsToConsider_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(20, relocateExpensiveChainNumArcsToConsider_);
    }
    if (cheapestInsertionNeighborsRatio_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(21, cheapestInsertionNeighborsRatio_);
    }
    if (logCostScalingFactor_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(22, logCostScalingFactor_);
    }
    if (savingsMaxMemoryUsageBytes_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(23, savingsMaxMemoryUsageBytes_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @Override
  public boolean equals(final Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof com.google.ortools.constraintsolver.RoutingSearchParameters)) {
      return super.equals(obj);
    }
    com.google.ortools.constraintsolver.RoutingSearchParameters other = (com.google.ortools.constraintsolver.RoutingSearchParameters) obj;

    if (firstSolutionStrategy_ != other.firstSolutionStrategy_) return false;
    if (getUseUnfilteredFirstSolutionStrategy()
        != other.getUseUnfilteredFirstSolutionStrategy()) return false;
    if (Double.doubleToLongBits(getSavingsNeighborsRatio())
        != Double.doubleToLongBits(
            other.getSavingsNeighborsRatio())) return false;
    if (Double.doubleToLongBits(getSavingsMaxMemoryUsageBytes())
        != Double.doubleToLongBits(
            other.getSavingsMaxMemoryUsageBytes())) return false;
    if (getSavingsAddReverseArcs()
        != other.getSavingsAddReverseArcs()) return false;
    if (Double.doubleToLongBits(getSavingsArcCoefficient())
        != Double.doubleToLongBits(
            other.getSavingsArcCoefficient())) return false;
    if (getSavingsParallelRoutes()
        != other.getSavingsParallelRoutes()) return false;
    if (Double.doubleToLongBits(getCheapestInsertionFarthestSeedsRatio())
        != Double.doubleToLongBits(
            other.getCheapestInsertionFarthestSeedsRatio())) return false;
    if (Double.doubleToLongBits(getCheapestInsertionNeighborsRatio())
        != Double.doubleToLongBits(
            other.getCheapestInsertionNeighborsRatio())) return false;
    if (hasLocalSearchOperators() != other.hasLocalSearchOperators()) return false;
    if (hasLocalSearchOperators()) {
      if (!getLocalSearchOperators()
          .equals(other.getLocalSearchOperators())) return false;
    }
    if (getRelocateExpensiveChainNumArcsToConsider()
        != other.getRelocateExpensiveChainNumArcsToConsider()) return false;
    if (localSearchMetaheuristic_ != other.localSearchMetaheuristic_) return false;
    if (Double.doubleToLongBits(getGuidedLocalSearchLambdaCoefficient())
        != Double.doubleToLongBits(
            other.getGuidedLocalSearchLambdaCoefficient())) return false;
    if (getUseDepthFirstSearch()
        != other.getUseDepthFirstSearch()) return false;
    if (Double.doubleToLongBits(getOptimizationStep())
        != Double.doubleToLongBits(
            other.getOptimizationStep())) return false;
    if (getNumberOfSolutionsToCollect()
        != other.getNumberOfSolutionsToCollect()) return false;
    if (getSolutionLimit()
        != other.getSolutionLimit()) return false;
    if (hasTimeLimit() != other.hasTimeLimit()) return false;
    if (hasTimeLimit()) {
      if (!getTimeLimit()
          .equals(other.getTimeLimit())) return false;
    }
    if (hasLnsTimeLimit() != other.hasLnsTimeLimit()) return false;
    if (hasLnsTimeLimit()) {
      if (!getLnsTimeLimit()
          .equals(other.getLnsTimeLimit())) return false;
    }
    if (getUseFullPropagation()
        != other.getUseFullPropagation()) return false;
    if (getLogSearch()
        != other.getLogSearch()) return false;
    if (Double.doubleToLongBits(getLogCostScalingFactor())
        != Double.doubleToLongBits(
            other.getLogCostScalingFactor())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + FIRST_SOLUTION_STRATEGY_FIELD_NUMBER;
    hash = (53 * hash) + firstSolutionStrategy_;
    hash = (37 * hash) + USE_UNFILTERED_FIRST_SOLUTION_STRATEGY_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getUseUnfilteredFirstSolutionStrategy());
    hash = (37 * hash) + SAVINGS_NEIGHBORS_RATIO_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getSavingsNeighborsRatio()));
    hash = (37 * hash) + SAVINGS_MAX_MEMORY_USAGE_BYTES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getSavingsMaxMemoryUsageBytes()));
    hash = (37 * hash) + SAVINGS_ADD_REVERSE_ARCS_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getSavingsAddReverseArcs());
    hash = (37 * hash) + SAVINGS_ARC_COEFFICIENT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getSavingsArcCoefficient()));
    hash = (37 * hash) + SAVINGS_PARALLEL_ROUTES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getSavingsParallelRoutes());
    hash = (37 * hash) + CHEAPEST_INSERTION_FARTHEST_SEEDS_RATIO_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getCheapestInsertionFarthestSeedsRatio()));
    hash = (37 * hash) + CHEAPEST_INSERTION_NEIGHBORS_RATIO_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getCheapestInsertionNeighborsRatio()));
    if (hasLocalSearchOperators()) {
      hash = (37 * hash) + LOCAL_SEARCH_OPERATORS_FIELD_NUMBER;
      hash = (53 * hash) + getLocalSearchOperators().hashCode();
    }
    hash = (37 * hash) + RELOCATE_EXPENSIVE_CHAIN_NUM_ARCS_TO_CONSIDER_FIELD_NUMBER;
    hash = (53 * hash) + getRelocateExpensiveChainNumArcsToConsider();
    hash = (37 * hash) + LOCAL_SEARCH_METAHEURISTIC_FIELD_NUMBER;
    hash = (53 * hash) + localSearchMetaheuristic_;
    hash = (37 * hash) + GUIDED_LOCAL_SEARCH_LAMBDA_COEFFICIENT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getGuidedLocalSearchLambdaCoefficient()));
    hash = (37 * hash) + USE_DEPTH_FIRST_SEARCH_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getUseDepthFirstSearch());
    hash = (37 * hash) + OPTIMIZATION_STEP_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getOptimizationStep()));
    hash = (37 * hash) + NUMBER_OF_SOLUTIONS_TO_COLLECT_FIELD_NUMBER;
    hash = (53 * hash) + getNumberOfSolutionsToCollect();
    hash = (37 * hash) + SOLUTION_LIMIT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getSolutionLimit());
    if (hasTimeLimit()) {
      hash = (37 * hash) + TIME_LIMIT_FIELD_NUMBER;
      hash = (53 * hash) + getTimeLimit().hashCode();
    }
    if (hasLnsTimeLimit()) {
      hash = (37 * hash) + LNS_TIME_LIMIT_FIELD_NUMBER;
      hash = (53 * hash) + getLnsTimeLimit().hashCode();
    }
    hash = (37 * hash) + USE_FULL_PROPAGATION_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getUseFullPropagation());
    hash = (37 * hash) + LOG_SEARCH_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getLogSearch());
    hash = (37 * hash) + LOG_COST_SCALING_FACTOR_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        Double.doubleToLongBits(getLogCostScalingFactor()));
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.google.ortools.constraintsolver.RoutingSearchParameters parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.ortools.constraintsolver.RoutingSearchParameters prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Parameters defining the search used to solve vehicle routing problems.
   * If a parameter is unset (or, equivalently, set to its default value),
   * then the routing library will pick its preferred value for that parameter
   * automatically: this should be the case for most parameters.
   * To see those "default" parameters, call GetDefaultRoutingSearchParameters().
   * </pre>
   *
   * Protobuf type {@code operations_research.RoutingSearchParameters}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:operations_research.RoutingSearchParameters)
      com.google.ortools.constraintsolver.RoutingSearchParametersOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_descriptor;
    }

    @Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.ortools.constraintsolver.RoutingSearchParameters.class, com.google.ortools.constraintsolver.RoutingSearchParameters.Builder.class);
    }

    // Construct using com.google.ortools.constraintsolver.RoutingSearchParameters.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @Override
    public Builder clear() {
      super.clear();
      firstSolutionStrategy_ = 0;

      useUnfilteredFirstSolutionStrategy_ = false;

      savingsNeighborsRatio_ = 0D;

      savingsMaxMemoryUsageBytes_ = 0D;

      savingsAddReverseArcs_ = false;

      savingsArcCoefficient_ = 0D;

      savingsParallelRoutes_ = false;

      cheapestInsertionFarthestSeedsRatio_ = 0D;

      cheapestInsertionNeighborsRatio_ = 0D;

      if (localSearchOperatorsBuilder_ == null) {
        localSearchOperators_ = null;
      } else {
        localSearchOperators_ = null;
        localSearchOperatorsBuilder_ = null;
      }
      relocateExpensiveChainNumArcsToConsider_ = 0;

      localSearchMetaheuristic_ = 0;

      guidedLocalSearchLambdaCoefficient_ = 0D;

      useDepthFirstSearch_ = false;

      optimizationStep_ = 0D;

      numberOfSolutionsToCollect_ = 0;

      solutionLimit_ = 0L;

      if (timeLimitBuilder_ == null) {
        timeLimit_ = null;
      } else {
        timeLimit_ = null;
        timeLimitBuilder_ = null;
      }
      if (lnsTimeLimitBuilder_ == null) {
        lnsTimeLimit_ = null;
      } else {
        lnsTimeLimit_ = null;
        lnsTimeLimitBuilder_ = null;
      }
      useFullPropagation_ = false;

      logSearch_ = false;

      logCostScalingFactor_ = 0D;

      return this;
    }

    @Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.google.ortools.constraintsolver.RoutingParameters.internal_static_operations_research_RoutingSearchParameters_descriptor;
    }

    @Override
    public com.google.ortools.constraintsolver.RoutingSearchParameters getDefaultInstanceForType() {
      return com.google.ortools.constraintsolver.RoutingSearchParameters.getDefaultInstance();
    }

    @Override
    public com.google.ortools.constraintsolver.RoutingSearchParameters build() {
      com.google.ortools.constraintsolver.RoutingSearchParameters result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @Override
    public com.google.ortools.constraintsolver.RoutingSearchParameters buildPartial() {
      com.google.ortools.constraintsolver.RoutingSearchParameters result = new com.google.ortools.constraintsolver.RoutingSearchParameters(this);
      result.firstSolutionStrategy_ = firstSolutionStrategy_;
      result.useUnfilteredFirstSolutionStrategy_ = useUnfilteredFirstSolutionStrategy_;
      result.savingsNeighborsRatio_ = savingsNeighborsRatio_;
      result.savingsMaxMemoryUsageBytes_ = savingsMaxMemoryUsageBytes_;
      result.savingsAddReverseArcs_ = savingsAddReverseArcs_;
      result.savingsArcCoefficient_ = savingsArcCoefficient_;
      result.savingsParallelRoutes_ = savingsParallelRoutes_;
      result.cheapestInsertionFarthestSeedsRatio_ = cheapestInsertionFarthestSeedsRatio_;
      result.cheapestInsertionNeighborsRatio_ = cheapestInsertionNeighborsRatio_;
      if (localSearchOperatorsBuilder_ == null) {
        result.localSearchOperators_ = localSearchOperators_;
      } else {
        result.localSearchOperators_ = localSearchOperatorsBuilder_.build();
      }
      result.relocateExpensiveChainNumArcsToConsider_ = relocateExpensiveChainNumArcsToConsider_;
      result.localSearchMetaheuristic_ = localSearchMetaheuristic_;
      result.guidedLocalSearchLambdaCoefficient_ = guidedLocalSearchLambdaCoefficient_;
      result.useDepthFirstSearch_ = useDepthFirstSearch_;
      result.optimizationStep_ = optimizationStep_;
      result.numberOfSolutionsToCollect_ = numberOfSolutionsToCollect_;
      result.solutionLimit_ = solutionLimit_;
      if (timeLimitBuilder_ == null) {
        result.timeLimit_ = timeLimit_;
      } else {
        result.timeLimit_ = timeLimitBuilder_.build();
      }
      if (lnsTimeLimitBuilder_ == null) {
        result.lnsTimeLimit_ = lnsTimeLimit_;
      } else {
        result.lnsTimeLimit_ = lnsTimeLimitBuilder_.build();
      }
      result.useFullPropagation_ = useFullPropagation_;
      result.logSearch_ = logSearch_;
      result.logCostScalingFactor_ = logCostScalingFactor_;
      onBuilt();
      return result;
    }

    @Override
    public Builder clone() {
      return super.clone();
    }
    @Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        Object value) {
      return super.setField(field, value);
    }
    @Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        Object value) {
      return super.addRepeatedField(field, value);
    }
    @Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.ortools.constraintsolver.RoutingSearchParameters) {
        return mergeFrom((com.google.ortools.constraintsolver.RoutingSearchParameters)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.ortools.constraintsolver.RoutingSearchParameters other) {
      if (other == com.google.ortools.constraintsolver.RoutingSearchParameters.getDefaultInstance()) return this;
      if (other.firstSolutionStrategy_ != 0) {
        setFirstSolutionStrategyValue(other.getFirstSolutionStrategyValue());
      }
      if (other.getUseUnfilteredFirstSolutionStrategy() != false) {
        setUseUnfilteredFirstSolutionStrategy(other.getUseUnfilteredFirstSolutionStrategy());
      }
      if (other.getSavingsNeighborsRatio() != 0D) {
        setSavingsNeighborsRatio(other.getSavingsNeighborsRatio());
      }
      if (other.getSavingsMaxMemoryUsageBytes() != 0D) {
        setSavingsMaxMemoryUsageBytes(other.getSavingsMaxMemoryUsageBytes());
      }
      if (other.getSavingsAddReverseArcs() != false) {
        setSavingsAddReverseArcs(other.getSavingsAddReverseArcs());
      }
      if (other.getSavingsArcCoefficient() != 0D) {
        setSavingsArcCoefficient(other.getSavingsArcCoefficient());
      }
      if (other.getSavingsParallelRoutes() != false) {
        setSavingsParallelRoutes(other.getSavingsParallelRoutes());
      }
      if (other.getCheapestInsertionFarthestSeedsRatio() != 0D) {
        setCheapestInsertionFarthestSeedsRatio(other.getCheapestInsertionFarthestSeedsRatio());
      }
      if (other.getCheapestInsertionNeighborsRatio() != 0D) {
        setCheapestInsertionNeighborsRatio(other.getCheapestInsertionNeighborsRatio());
      }
      if (other.hasLocalSearchOperators()) {
        mergeLocalSearchOperators(other.getLocalSearchOperators());
      }
      if (other.getRelocateExpensiveChainNumArcsToConsider() != 0) {
        setRelocateExpensiveChainNumArcsToConsider(other.getRelocateExpensiveChainNumArcsToConsider());
      }
      if (other.localSearchMetaheuristic_ != 0) {
        setLocalSearchMetaheuristicValue(other.getLocalSearchMetaheuristicValue());
      }
      if (other.getGuidedLocalSearchLambdaCoefficient() != 0D) {
        setGuidedLocalSearchLambdaCoefficient(other.getGuidedLocalSearchLambdaCoefficient());
      }
      if (other.getUseDepthFirstSearch() != false) {
        setUseDepthFirstSearch(other.getUseDepthFirstSearch());
      }
      if (other.getOptimizationStep() != 0D) {
        setOptimizationStep(other.getOptimizationStep());
      }
      if (other.getNumberOfSolutionsToCollect() != 0) {
        setNumberOfSolutionsToCollect(other.getNumberOfSolutionsToCollect());
      }
      if (other.getSolutionLimit() != 0L) {
        setSolutionLimit(other.getSolutionLimit());
      }
      if (other.hasTimeLimit()) {
        mergeTimeLimit(other.getTimeLimit());
      }
      if (other.hasLnsTimeLimit()) {
        mergeLnsTimeLimit(other.getLnsTimeLimit());
      }
      if (other.getUseFullPropagation() != false) {
        setUseFullPropagation(other.getUseFullPropagation());
      }
      if (other.getLogSearch() != false) {
        setLogSearch(other.getLogSearch());
      }
      if (other.getLogCostScalingFactor() != 0D) {
        setLogCostScalingFactor(other.getLogCostScalingFactor());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @Override
    public final boolean isInitialized() {
      return true;
    }

    @Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.ortools.constraintsolver.RoutingSearchParameters parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.ortools.constraintsolver.RoutingSearchParameters) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int firstSolutionStrategy_ = 0;
    /**
     * <pre>
     * First solution strategies, used as starting point of local search.
     * </pre>
     *
     * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
     */
    public int getFirstSolutionStrategyValue() {
      return firstSolutionStrategy_;
    }
    /**
     * <pre>
     * First solution strategies, used as starting point of local search.
     * </pre>
     *
     * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
     */
    public Builder setFirstSolutionStrategyValue(int value) {
      firstSolutionStrategy_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * First solution strategies, used as starting point of local search.
     * </pre>
     *
     * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
     */
    public com.google.ortools.constraintsolver.FirstSolutionStrategy.Value getFirstSolutionStrategy() {
      @SuppressWarnings("deprecation")
      com.google.ortools.constraintsolver.FirstSolutionStrategy.Value result = com.google.ortools.constraintsolver.FirstSolutionStrategy.Value.valueOf(firstSolutionStrategy_);
      return result == null ? com.google.ortools.constraintsolver.FirstSolutionStrategy.Value.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * First solution strategies, used as starting point of local search.
     * </pre>
     *
     * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
     */
    public Builder setFirstSolutionStrategy(com.google.ortools.constraintsolver.FirstSolutionStrategy.Value value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      firstSolutionStrategy_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * First solution strategies, used as starting point of local search.
     * </pre>
     *
     * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
     */
    public Builder clearFirstSolutionStrategy() {
      
      firstSolutionStrategy_ = 0;
      onChanged();
      return this;
    }

    private boolean useUnfilteredFirstSolutionStrategy_ ;
    /**
     * <pre>
     * --- Advanced first solutions strategy settings ---
     * Don't touch these unless you know what you are doing.
     * Use filtered version of first solution strategy if available.
     * </pre>
     *
     * <code>bool use_unfiltered_first_solution_strategy = 2;</code>
     */
    public boolean getUseUnfilteredFirstSolutionStrategy() {
      return useUnfilteredFirstSolutionStrategy_;
    }
    /**
     * <pre>
     * --- Advanced first solutions strategy settings ---
     * Don't touch these unless you know what you are doing.
     * Use filtered version of first solution strategy if available.
     * </pre>
     *
     * <code>bool use_unfiltered_first_solution_strategy = 2;</code>
     */
    public Builder setUseUnfilteredFirstSolutionStrategy(boolean value) {
      
      useUnfilteredFirstSolutionStrategy_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * --- Advanced first solutions strategy settings ---
     * Don't touch these unless you know what you are doing.
     * Use filtered version of first solution strategy if available.
     * </pre>
     *
     * <code>bool use_unfiltered_first_solution_strategy = 2;</code>
     */
    public Builder clearUseUnfilteredFirstSolutionStrategy() {
      
      useUnfilteredFirstSolutionStrategy_ = false;
      onChanged();
      return this;
    }

    private double savingsNeighborsRatio_ ;
    /**
     * <pre>
     * Parameters specific to the Savings first solution heuristic.
     * Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
     * the savings. If unspecified, its value is considered to be 1.0.
     * </pre>
     *
     * <code>double savings_neighbors_ratio = 14;</code>
     */
    public double getSavingsNeighborsRatio() {
      return savingsNeighborsRatio_;
    }
    /**
     * <pre>
     * Parameters specific to the Savings first solution heuristic.
     * Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
     * the savings. If unspecified, its value is considered to be 1.0.
     * </pre>
     *
     * <code>double savings_neighbors_ratio = 14;</code>
     */
    public Builder setSavingsNeighborsRatio(double value) {
      
      savingsNeighborsRatio_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Parameters specific to the Savings first solution heuristic.
     * Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
     * the savings. If unspecified, its value is considered to be 1.0.
     * </pre>
     *
     * <code>double savings_neighbors_ratio = 14;</code>
     */
    public Builder clearSavingsNeighborsRatio() {
      
      savingsNeighborsRatio_ = 0D;
      onChanged();
      return this;
    }

    private double savingsMaxMemoryUsageBytes_ ;
    /**
     * <pre>
     * The number of neighbors considered for each node in the Savings heuristic
     * is chosen so that the space used to store the savings doesn't exceed
     * savings_max_memory_usage_bytes, which must be in ]0, 1e10].
     * NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
     * are specified, the number of neighbors considered for each node will be the
     * minimum of the two numbers determined by these parameters.
     * </pre>
     *
     * <code>double savings_max_memory_usage_bytes = 23;</code>
     */
    public double getSavingsMaxMemoryUsageBytes() {
      return savingsMaxMemoryUsageBytes_;
    }
    /**
     * <pre>
     * The number of neighbors considered for each node in the Savings heuristic
     * is chosen so that the space used to store the savings doesn't exceed
     * savings_max_memory_usage_bytes, which must be in ]0, 1e10].
     * NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
     * are specified, the number of neighbors considered for each node will be the
     * minimum of the two numbers determined by these parameters.
     * </pre>
     *
     * <code>double savings_max_memory_usage_bytes = 23;</code>
     */
    public Builder setSavingsMaxMemoryUsageBytes(double value) {
      
      savingsMaxMemoryUsageBytes_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of neighbors considered for each node in the Savings heuristic
     * is chosen so that the space used to store the savings doesn't exceed
     * savings_max_memory_usage_bytes, which must be in ]0, 1e10].
     * NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
     * are specified, the number of neighbors considered for each node will be the
     * minimum of the two numbers determined by these parameters.
     * </pre>
     *
     * <code>double savings_max_memory_usage_bytes = 23;</code>
     */
    public Builder clearSavingsMaxMemoryUsageBytes() {
      
      savingsMaxMemoryUsageBytes_ = 0D;
      onChanged();
      return this;
    }

    private boolean savingsAddReverseArcs_ ;
    /**
     * <pre>
     * Add savings related to reverse arcs when finding the nearest neighbors
     * of the nodes.
     * </pre>
     *
     * <code>bool savings_add_reverse_arcs = 15;</code>
     */
    public boolean getSavingsAddReverseArcs() {
      return savingsAddReverseArcs_;
    }
    /**
     * <pre>
     * Add savings related to reverse arcs when finding the nearest neighbors
     * of the nodes.
     * </pre>
     *
     * <code>bool savings_add_reverse_arcs = 15;</code>
     */
    public Builder setSavingsAddReverseArcs(boolean value) {
      
      savingsAddReverseArcs_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Add savings related to reverse arcs when finding the nearest neighbors
     * of the nodes.
     * </pre>
     *
     * <code>bool savings_add_reverse_arcs = 15;</code>
     */
    public Builder clearSavingsAddReverseArcs() {
      
      savingsAddReverseArcs_ = false;
      onChanged();
      return this;
    }

    private double savingsArcCoefficient_ ;
    /**
     * <pre>
     * Coefficient of the cost of the arc for which the saving value is being
     * computed:
     * Saving(a--&gt;b) = Cost(a--&gt;end) + Cost(start--&gt;b)
     *                 - savings_arc_coefficient * Cost(a--&gt;b)
     * This parameter must be greater than 0, and its default value is 1.
     * </pre>
     *
     * <code>double savings_arc_coefficient = 18;</code>
     */
    public double getSavingsArcCoefficient() {
      return savingsArcCoefficient_;
    }
    /**
     * <pre>
     * Coefficient of the cost of the arc for which the saving value is being
     * computed:
     * Saving(a--&gt;b) = Cost(a--&gt;end) + Cost(start--&gt;b)
     *                 - savings_arc_coefficient * Cost(a--&gt;b)
     * This parameter must be greater than 0, and its default value is 1.
     * </pre>
     *
     * <code>double savings_arc_coefficient = 18;</code>
     */
    public Builder setSavingsArcCoefficient(double value) {
      
      savingsArcCoefficient_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Coefficient of the cost of the arc for which the saving value is being
     * computed:
     * Saving(a--&gt;b) = Cost(a--&gt;end) + Cost(start--&gt;b)
     *                 - savings_arc_coefficient * Cost(a--&gt;b)
     * This parameter must be greater than 0, and its default value is 1.
     * </pre>
     *
     * <code>double savings_arc_coefficient = 18;</code>
     */
    public Builder clearSavingsArcCoefficient() {
      
      savingsArcCoefficient_ = 0D;
      onChanged();
      return this;
    }

    private boolean savingsParallelRoutes_ ;
    /**
     * <pre>
     * When true, the routes are built in parallel, sequentially otherwise.
     * </pre>
     *
     * <code>bool savings_parallel_routes = 19;</code>
     */
    public boolean getSavingsParallelRoutes() {
      return savingsParallelRoutes_;
    }
    /**
     * <pre>
     * When true, the routes are built in parallel, sequentially otherwise.
     * </pre>
     *
     * <code>bool savings_parallel_routes = 19;</code>
     */
    public Builder setSavingsParallelRoutes(boolean value) {
      
      savingsParallelRoutes_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * When true, the routes are built in parallel, sequentially otherwise.
     * </pre>
     *
     * <code>bool savings_parallel_routes = 19;</code>
     */
    public Builder clearSavingsParallelRoutes() {
      
      savingsParallelRoutes_ = false;
      onChanged();
      return this;
    }

    private double cheapestInsertionFarthestSeedsRatio_ ;
    /**
     * <pre>
     * Ratio (between 0 and 1) of available vehicles in the model on which
     * farthest nodes of the model are inserted as seeds in the
     * GlobalCheapestInsertion first solution heuristic.
     * </pre>
     *
     * <code>double cheapest_insertion_farthest_seeds_ratio = 16;</code>
     */
    public double getCheapestInsertionFarthestSeedsRatio() {
      return cheapestInsertionFarthestSeedsRatio_;
    }
    /**
     * <pre>
     * Ratio (between 0 and 1) of available vehicles in the model on which
     * farthest nodes of the model are inserted as seeds in the
     * GlobalCheapestInsertion first solution heuristic.
     * </pre>
     *
     * <code>double cheapest_insertion_farthest_seeds_ratio = 16;</code>
     */
    public Builder setCheapestInsertionFarthestSeedsRatio(double value) {
      
      cheapestInsertionFarthestSeedsRatio_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Ratio (between 0 and 1) of available vehicles in the model on which
     * farthest nodes of the model are inserted as seeds in the
     * GlobalCheapestInsertion first solution heuristic.
     * </pre>
     *
     * <code>double cheapest_insertion_farthest_seeds_ratio = 16;</code>
     */
    public Builder clearCheapestInsertionFarthestSeedsRatio() {
      
      cheapestInsertionFarthestSeedsRatio_ = 0D;
      onChanged();
      return this;
    }

    private double cheapestInsertionNeighborsRatio_ ;
    /**
     * <pre>
     * Ratio (in ]0, 1]) of neighbors to consider for each node when creating
     * new insertions in the parallel/sequential cheapest insertion heuristic.
     * If not overridden, its default value is 1, meaning all neighbors will be
     * considered.
     * </pre>
     *
     * <code>double cheapest_insertion_neighbors_ratio = 21;</code>
     */
    public double getCheapestInsertionNeighborsRatio() {
      return cheapestInsertionNeighborsRatio_;
    }
    /**
     * <pre>
     * Ratio (in ]0, 1]) of neighbors to consider for each node when creating
     * new insertions in the parallel/sequential cheapest insertion heuristic.
     * If not overridden, its default value is 1, meaning all neighbors will be
     * considered.
     * </pre>
     *
     * <code>double cheapest_insertion_neighbors_ratio = 21;</code>
     */
    public Builder setCheapestInsertionNeighborsRatio(double value) {
      
      cheapestInsertionNeighborsRatio_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Ratio (in ]0, 1]) of neighbors to consider for each node when creating
     * new insertions in the parallel/sequential cheapest insertion heuristic.
     * If not overridden, its default value is 1, meaning all neighbors will be
     * considered.
     * </pre>
     *
     * <code>double cheapest_insertion_neighbors_ratio = 21;</code>
     */
    public Builder clearCheapestInsertionNeighborsRatio() {
      
      cheapestInsertionNeighborsRatio_ = 0D;
      onChanged();
      return this;
    }

    private com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators localSearchOperators_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder> localSearchOperatorsBuilder_;
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public boolean hasLocalSearchOperators() {
      return localSearchOperatorsBuilder_ != null || localSearchOperators_ != null;
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators getLocalSearchOperators() {
      if (localSearchOperatorsBuilder_ == null) {
        return localSearchOperators_ == null ? com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.getDefaultInstance() : localSearchOperators_;
      } else {
        return localSearchOperatorsBuilder_.getMessage();
      }
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public Builder setLocalSearchOperators(com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators value) {
      if (localSearchOperatorsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        localSearchOperators_ = value;
        onChanged();
      } else {
        localSearchOperatorsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public Builder setLocalSearchOperators(
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder builderForValue) {
      if (localSearchOperatorsBuilder_ == null) {
        localSearchOperators_ = builderForValue.build();
        onChanged();
      } else {
        localSearchOperatorsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public Builder mergeLocalSearchOperators(com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators value) {
      if (localSearchOperatorsBuilder_ == null) {
        if (localSearchOperators_ != null) {
          localSearchOperators_ =
            com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.newBuilder(localSearchOperators_).mergeFrom(value).buildPartial();
        } else {
          localSearchOperators_ = value;
        }
        onChanged();
      } else {
        localSearchOperatorsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public Builder clearLocalSearchOperators() {
      if (localSearchOperatorsBuilder_ == null) {
        localSearchOperators_ = null;
        onChanged();
      } else {
        localSearchOperators_ = null;
        localSearchOperatorsBuilder_ = null;
      }

      return this;
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder getLocalSearchOperatorsBuilder() {
      
      onChanged();
      return getLocalSearchOperatorsFieldBuilder().getBuilder();
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    public com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder getLocalSearchOperatorsOrBuilder() {
      if (localSearchOperatorsBuilder_ != null) {
        return localSearchOperatorsBuilder_.getMessageOrBuilder();
      } else {
        return localSearchOperators_ == null ?
            com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.getDefaultInstance() : localSearchOperators_;
      }
    }
    /**
     * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder> 
        getLocalSearchOperatorsFieldBuilder() {
      if (localSearchOperatorsBuilder_ == null) {
        localSearchOperatorsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators.Builder, com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder>(
                getLocalSearchOperators(),
                getParentForChildren(),
                isClean());
        localSearchOperators_ = null;
      }
      return localSearchOperatorsBuilder_;
    }

    private int relocateExpensiveChainNumArcsToConsider_ ;
    /**
     * <pre>
     * Number of expensive arcs to consider cutting in the RelocateExpensiveChain
     * neighborhood operator (see
     * LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
     * This parameter must be greater than 2.
     * NOTE(user): The number of neighbors generated by the operator for
     * relocate_expensive_chain_num_arcs_to_consider = K is around
     * K*(K-1)/2 * number_of_routes * number_of_nodes.
     * </pre>
     *
     * <code>int32 relocate_expensive_chain_num_arcs_to_consider = 20;</code>
     */
    public int getRelocateExpensiveChainNumArcsToConsider() {
      return relocateExpensiveChainNumArcsToConsider_;
    }
    /**
     * <pre>
     * Number of expensive arcs to consider cutting in the RelocateExpensiveChain
     * neighborhood operator (see
     * LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
     * This parameter must be greater than 2.
     * NOTE(user): The number of neighbors generated by the operator for
     * relocate_expensive_chain_num_arcs_to_consider = K is around
     * K*(K-1)/2 * number_of_routes * number_of_nodes.
     * </pre>
     *
     * <code>int32 relocate_expensive_chain_num_arcs_to_consider = 20;</code>
     */
    public Builder setRelocateExpensiveChainNumArcsToConsider(int value) {
      
      relocateExpensiveChainNumArcsToConsider_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Number of expensive arcs to consider cutting in the RelocateExpensiveChain
     * neighborhood operator (see
     * LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
     * This parameter must be greater than 2.
     * NOTE(user): The number of neighbors generated by the operator for
     * relocate_expensive_chain_num_arcs_to_consider = K is around
     * K*(K-1)/2 * number_of_routes * number_of_nodes.
     * </pre>
     *
     * <code>int32 relocate_expensive_chain_num_arcs_to_consider = 20;</code>
     */
    public Builder clearRelocateExpensiveChainNumArcsToConsider() {
      
      relocateExpensiveChainNumArcsToConsider_ = 0;
      onChanged();
      return this;
    }

    private int localSearchMetaheuristic_ = 0;
    /**
     * <pre>
     * Local search metaheuristics used to guide the search.
     * </pre>
     *
     * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
     */
    public int getLocalSearchMetaheuristicValue() {
      return localSearchMetaheuristic_;
    }
    /**
     * <pre>
     * Local search metaheuristics used to guide the search.
     * </pre>
     *
     * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
     */
    public Builder setLocalSearchMetaheuristicValue(int value) {
      localSearchMetaheuristic_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Local search metaheuristics used to guide the search.
     * </pre>
     *
     * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
     */
    public com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value getLocalSearchMetaheuristic() {
      @SuppressWarnings("deprecation")
      com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value result = com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value.valueOf(localSearchMetaheuristic_);
      return result == null ? com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Local search metaheuristics used to guide the search.
     * </pre>
     *
     * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
     */
    public Builder setLocalSearchMetaheuristic(com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      localSearchMetaheuristic_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Local search metaheuristics used to guide the search.
     * </pre>
     *
     * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
     */
    public Builder clearLocalSearchMetaheuristic() {
      
      localSearchMetaheuristic_ = 0;
      onChanged();
      return this;
    }

    private double guidedLocalSearchLambdaCoefficient_ ;
    /**
     * <pre>
     * These are advanced settings which should not be modified unless you know
     * what you are doing.
     * Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
     * used. Must be positive.
     * </pre>
     *
     * <code>double guided_local_search_lambda_coefficient = 5;</code>
     */
    public double getGuidedLocalSearchLambdaCoefficient() {
      return guidedLocalSearchLambdaCoefficient_;
    }
    /**
     * <pre>
     * These are advanced settings which should not be modified unless you know
     * what you are doing.
     * Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
     * used. Must be positive.
     * </pre>
     *
     * <code>double guided_local_search_lambda_coefficient = 5;</code>
     */
    public Builder setGuidedLocalSearchLambdaCoefficient(double value) {
      
      guidedLocalSearchLambdaCoefficient_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * These are advanced settings which should not be modified unless you know
     * what you are doing.
     * Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
     * used. Must be positive.
     * </pre>
     *
     * <code>double guided_local_search_lambda_coefficient = 5;</code>
     */
    public Builder clearGuidedLocalSearchLambdaCoefficient() {
      
      guidedLocalSearchLambdaCoefficient_ = 0D;
      onChanged();
      return this;
    }

    private boolean useDepthFirstSearch_ ;
    /**
     * <pre>
     * --- Search control ---
     * If true, the solver should use depth-first search rather than local search
     * to solve the problem.
     * </pre>
     *
     * <code>bool use_depth_first_search = 6;</code>
     */
    public boolean getUseDepthFirstSearch() {
      return useDepthFirstSearch_;
    }
    /**
     * <pre>
     * --- Search control ---
     * If true, the solver should use depth-first search rather than local search
     * to solve the problem.
     * </pre>
     *
     * <code>bool use_depth_first_search = 6;</code>
     */
    public Builder setUseDepthFirstSearch(boolean value) {
      
      useDepthFirstSearch_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * --- Search control ---
     * If true, the solver should use depth-first search rather than local search
     * to solve the problem.
     * </pre>
     *
     * <code>bool use_depth_first_search = 6;</code>
     */
    public Builder clearUseDepthFirstSearch() {
      
      useDepthFirstSearch_ = false;
      onChanged();
      return this;
    }

    private double optimizationStep_ ;
    /**
     * <pre>
     * Minimum step by which the solution must be improved in local search. 0
     * means "unspecified". If this value is fractional, it will get rounded to
     * the nearest integer.
     * </pre>
     *
     * <code>double optimization_step = 7;</code>
     */
    public double getOptimizationStep() {
      return optimizationStep_;
    }
    /**
     * <pre>
     * Minimum step by which the solution must be improved in local search. 0
     * means "unspecified". If this value is fractional, it will get rounded to
     * the nearest integer.
     * </pre>
     *
     * <code>double optimization_step = 7;</code>
     */
    public Builder setOptimizationStep(double value) {
      
      optimizationStep_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Minimum step by which the solution must be improved in local search. 0
     * means "unspecified". If this value is fractional, it will get rounded to
     * the nearest integer.
     * </pre>
     *
     * <code>double optimization_step = 7;</code>
     */
    public Builder clearOptimizationStep() {
      
      optimizationStep_ = 0D;
      onChanged();
      return this;
    }

    private int numberOfSolutionsToCollect_ ;
    /**
     * <pre>
     * Number of solutions to collect during the search. Corresponds to the best
     * solutions found during the search. 0 means "unspecified".
     * </pre>
     *
     * <code>int32 number_of_solutions_to_collect = 17;</code>
     */
    public int getNumberOfSolutionsToCollect() {
      return numberOfSolutionsToCollect_;
    }
    /**
     * <pre>
     * Number of solutions to collect during the search. Corresponds to the best
     * solutions found during the search. 0 means "unspecified".
     * </pre>
     *
     * <code>int32 number_of_solutions_to_collect = 17;</code>
     */
    public Builder setNumberOfSolutionsToCollect(int value) {
      
      numberOfSolutionsToCollect_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Number of solutions to collect during the search. Corresponds to the best
     * solutions found during the search. 0 means "unspecified".
     * </pre>
     *
     * <code>int32 number_of_solutions_to_collect = 17;</code>
     */
    public Builder clearNumberOfSolutionsToCollect() {
      
      numberOfSolutionsToCollect_ = 0;
      onChanged();
      return this;
    }

    private long solutionLimit_ ;
    /**
     * <pre>
     * -- Search limits --
     * Limit to the number of solutions generated during the search. 0 means
     * "unspecified".
     * </pre>
     *
     * <code>int64 solution_limit = 8;</code>
     */
    public long getSolutionLimit() {
      return solutionLimit_;
    }
    /**
     * <pre>
     * -- Search limits --
     * Limit to the number of solutions generated during the search. 0 means
     * "unspecified".
     * </pre>
     *
     * <code>int64 solution_limit = 8;</code>
     */
    public Builder setSolutionLimit(long value) {
      
      solutionLimit_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * -- Search limits --
     * Limit to the number of solutions generated during the search. 0 means
     * "unspecified".
     * </pre>
     *
     * <code>int64 solution_limit = 8;</code>
     */
    public Builder clearSolutionLimit() {
      
      solutionLimit_ = 0L;
      onChanged();
      return this;
    }

    private com.google.protobuf.Duration timeLimit_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> timeLimitBuilder_;
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public boolean hasTimeLimit() {
      return timeLimitBuilder_ != null || timeLimit_ != null;
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public com.google.protobuf.Duration getTimeLimit() {
      if (timeLimitBuilder_ == null) {
        return timeLimit_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeLimit_;
      } else {
        return timeLimitBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public Builder setTimeLimit(com.google.protobuf.Duration value) {
      if (timeLimitBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        timeLimit_ = value;
        onChanged();
      } else {
        timeLimitBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public Builder setTimeLimit(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (timeLimitBuilder_ == null) {
        timeLimit_ = builderForValue.build();
        onChanged();
      } else {
        timeLimitBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public Builder mergeTimeLimit(com.google.protobuf.Duration value) {
      if (timeLimitBuilder_ == null) {
        if (timeLimit_ != null) {
          timeLimit_ =
            com.google.protobuf.Duration.newBuilder(timeLimit_).mergeFrom(value).buildPartial();
        } else {
          timeLimit_ = value;
        }
        onChanged();
      } else {
        timeLimitBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public Builder clearTimeLimit() {
      if (timeLimitBuilder_ == null) {
        timeLimit_ = null;
        onChanged();
      } else {
        timeLimit_ = null;
        timeLimitBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public com.google.protobuf.Duration.Builder getTimeLimitBuilder() {
      
      onChanged();
      return getTimeLimitFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    public com.google.protobuf.DurationOrBuilder getTimeLimitOrBuilder() {
      if (timeLimitBuilder_ != null) {
        return timeLimitBuilder_.getMessageOrBuilder();
      } else {
        return timeLimit_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : timeLimit_;
      }
    }
    /**
     * <pre>
     * Limit to the time spent in the search.
     * </pre>
     *
     * <code>.google.protobuf.Duration time_limit = 9;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getTimeLimitFieldBuilder() {
      if (timeLimitBuilder_ == null) {
        timeLimitBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getTimeLimit(),
                getParentForChildren(),
                isClean());
        timeLimit_ = null;
      }
      return timeLimitBuilder_;
    }

    private com.google.protobuf.Duration lnsTimeLimit_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> lnsTimeLimitBuilder_;
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public boolean hasLnsTimeLimit() {
      return lnsTimeLimitBuilder_ != null || lnsTimeLimit_ != null;
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public com.google.protobuf.Duration getLnsTimeLimit() {
      if (lnsTimeLimitBuilder_ == null) {
        return lnsTimeLimit_ == null ? com.google.protobuf.Duration.getDefaultInstance() : lnsTimeLimit_;
      } else {
        return lnsTimeLimitBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public Builder setLnsTimeLimit(com.google.protobuf.Duration value) {
      if (lnsTimeLimitBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lnsTimeLimit_ = value;
        onChanged();
      } else {
        lnsTimeLimitBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public Builder setLnsTimeLimit(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (lnsTimeLimitBuilder_ == null) {
        lnsTimeLimit_ = builderForValue.build();
        onChanged();
      } else {
        lnsTimeLimitBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public Builder mergeLnsTimeLimit(com.google.protobuf.Duration value) {
      if (lnsTimeLimitBuilder_ == null) {
        if (lnsTimeLimit_ != null) {
          lnsTimeLimit_ =
            com.google.protobuf.Duration.newBuilder(lnsTimeLimit_).mergeFrom(value).buildPartial();
        } else {
          lnsTimeLimit_ = value;
        }
        onChanged();
      } else {
        lnsTimeLimitBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public Builder clearLnsTimeLimit() {
      if (lnsTimeLimitBuilder_ == null) {
        lnsTimeLimit_ = null;
        onChanged();
      } else {
        lnsTimeLimit_ = null;
        lnsTimeLimitBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public com.google.protobuf.Duration.Builder getLnsTimeLimitBuilder() {
      
      onChanged();
      return getLnsTimeLimitFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    public com.google.protobuf.DurationOrBuilder getLnsTimeLimitOrBuilder() {
      if (lnsTimeLimitBuilder_ != null) {
        return lnsTimeLimitBuilder_.getMessageOrBuilder();
      } else {
        return lnsTimeLimit_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : lnsTimeLimit_;
      }
    }
    /**
     * <pre>
     * Limit to the time spent in the completion search for each local search
     * neighbor.
     * </pre>
     *
     * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getLnsTimeLimitFieldBuilder() {
      if (lnsTimeLimitBuilder_ == null) {
        lnsTimeLimitBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getLnsTimeLimit(),
                getParentForChildren(),
                isClean());
        lnsTimeLimit_ = null;
      }
      return lnsTimeLimitBuilder_;
    }

    private boolean useFullPropagation_ ;
    /**
     * <pre>
     * --- Propagation control ---
     * These are advanced settings which should not be modified unless you know
     * what you are doing.
     * Use constraints with full propagation in routing model (instead of 'light'
     * propagation only). Full propagation is only necessary when using
     * depth-first search or for models which require strong propagation to
     * finalize the value of secondary variables.
     * Changing this setting to true will slow down the search in most cases and
     * increase memory consumption in all cases.
     * </pre>
     *
     * <code>bool use_full_propagation = 11;</code>
     */
    public boolean getUseFullPropagation() {
      return useFullPropagation_;
    }
    /**
     * <pre>
     * --- Propagation control ---
     * These are advanced settings which should not be modified unless you know
     * what you are doing.
     * Use constraints with full propagation in routing model (instead of 'light'
     * propagation only). Full propagation is only necessary when using
     * depth-first search or for models which require strong propagation to
     * finalize the value of secondary variables.
     * Changing this setting to true will slow down the search in most cases and
     * increase memory consumption in all cases.
     * </pre>
     *
     * <code>bool use_full_propagation = 11;</code>
     */
    public Builder setUseFullPropagation(boolean value) {
      
      useFullPropagation_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * --- Propagation control ---
     * These are advanced settings which should not be modified unless you know
     * what you are doing.
     * Use constraints with full propagation in routing model (instead of 'light'
     * propagation only). Full propagation is only necessary when using
     * depth-first search or for models which require strong propagation to
     * finalize the value of secondary variables.
     * Changing this setting to true will slow down the search in most cases and
     * increase memory consumption in all cases.
     * </pre>
     *
     * <code>bool use_full_propagation = 11;</code>
     */
    public Builder clearUseFullPropagation() {
      
      useFullPropagation_ = false;
      onChanged();
      return this;
    }

    private boolean logSearch_ ;
    /**
     * <pre>
     * --- Miscellaneous ---
     * Some of these are advanced settings which should not be modified unless you
     * know what you are doing.
     * Activates search logging. For each solution found during the search, the
     * following will be displayed: its objective value, the maximum objective
     * value since the beginning of the search, the elapsed time since the
     * beginning of the search, the number of branches explored in the search
     * tree, the number of failures in the search tree, the depth of the search
     * tree, the number of local search neighbors explored, the number of local
     * search neighbors filtered by local search filters, the number of local
     * search neighbors accepted, the total memory used and the percentage of the
     * search done.
     * </pre>
     *
     * <code>bool log_search = 13;</code>
     */
    public boolean getLogSearch() {
      return logSearch_;
    }
    /**
     * <pre>
     * --- Miscellaneous ---
     * Some of these are advanced settings which should not be modified unless you
     * know what you are doing.
     * Activates search logging. For each solution found during the search, the
     * following will be displayed: its objective value, the maximum objective
     * value since the beginning of the search, the elapsed time since the
     * beginning of the search, the number of branches explored in the search
     * tree, the number of failures in the search tree, the depth of the search
     * tree, the number of local search neighbors explored, the number of local
     * search neighbors filtered by local search filters, the number of local
     * search neighbors accepted, the total memory used and the percentage of the
     * search done.
     * </pre>
     *
     * <code>bool log_search = 13;</code>
     */
    public Builder setLogSearch(boolean value) {
      
      logSearch_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * --- Miscellaneous ---
     * Some of these are advanced settings which should not be modified unless you
     * know what you are doing.
     * Activates search logging. For each solution found during the search, the
     * following will be displayed: its objective value, the maximum objective
     * value since the beginning of the search, the elapsed time since the
     * beginning of the search, the number of branches explored in the search
     * tree, the number of failures in the search tree, the depth of the search
     * tree, the number of local search neighbors explored, the number of local
     * search neighbors filtered by local search filters, the number of local
     * search neighbors accepted, the total memory used and the percentage of the
     * search done.
     * </pre>
     *
     * <code>bool log_search = 13;</code>
     */
    public Builder clearLogSearch() {
      
      logSearch_ = false;
      onChanged();
      return this;
    }

    private double logCostScalingFactor_ ;
    /**
     * <pre>
     * In logs, cost values will be unscaled by this factor.
     * </pre>
     *
     * <code>double log_cost_scaling_factor = 22;</code>
     */
    public double getLogCostScalingFactor() {
      return logCostScalingFactor_;
    }
    /**
     * <pre>
     * In logs, cost values will be unscaled by this factor.
     * </pre>
     *
     * <code>double log_cost_scaling_factor = 22;</code>
     */
    public Builder setLogCostScalingFactor(double value) {
      
      logCostScalingFactor_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * In logs, cost values will be unscaled by this factor.
     * </pre>
     *
     * <code>double log_cost_scaling_factor = 22;</code>
     */
    public Builder clearLogCostScalingFactor() {
      
      logCostScalingFactor_ = 0D;
      onChanged();
      return this;
    }
    @Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:operations_research.RoutingSearchParameters)
  }

  // @@protoc_insertion_point(class_scope:operations_research.RoutingSearchParameters)
  private static final com.google.ortools.constraintsolver.RoutingSearchParameters DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.google.ortools.constraintsolver.RoutingSearchParameters();
  }

  public static com.google.ortools.constraintsolver.RoutingSearchParameters getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<RoutingSearchParameters>
      PARSER = new com.google.protobuf.AbstractParser<RoutingSearchParameters>() {
    @Override
    public RoutingSearchParameters parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new RoutingSearchParameters(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<RoutingSearchParameters> parser() {
    return PARSER;
  }

  @Override
  public com.google.protobuf.Parser<RoutingSearchParameters> getParserForType() {
    return PARSER;
  }

  @Override
  public com.google.ortools.constraintsolver.RoutingSearchParameters getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

